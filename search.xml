<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[读书工具：Kindle]]></title>
    <url>%2F2019%2F11%2F22%2F%E8%AF%BB%E4%B9%A6%E5%B7%A5%E5%85%B7%EF%BC%9AKindle%2F</url>
    <content type="text"><![CDATA[本站迁移到 新博客，不再维护该站。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;阅读本文，大约需要4分钟一、前言&emsp;&emsp;这篇文章适合喜欢看书的朋友们，我本身也是个喜欢看书的人，但是书买多了就有了让我觉得头疼的事：&emsp;- 书太多了，搬家特别不方便，快递又太贵了&emsp;- 躺在床上，卧着捧书，有些书太重了，捧着手酸&emsp;- 看书的时候，如果灯光效果不好，看的眼睛酸痛&emsp;- 占地方，特别是对我这刚毕业出来租房子的小年轻，租个小单间还要被一堆书抢地方&emsp;&emsp;哈哈哈，这些只是我适当吐槽一下，其实看纸质书优点还是特别多的，买Kindle只是满足了我自己的需求，轻巧方便携带。二、Kindle的优点&emsp;&emsp;关于Kindle的优点其实网上有特别多，就实际体验来说，对我最实在的优点就是：我本人深受近视的折磨已经很久了，我的工作天天都对着电脑对着手机，久了眼睛会很干燥会很酸，回去还用手机看书或者看纸质书对眼睛简直是折磨，了解了Kindle采用的是电子水墨屏而且还有背光(部分机型没有)的功能是吸引我购买的原因之一，因为在家看纸质书对我的困扰除了捧书重还有一点原因就是我没办法控制我的灯光，久看眼睛特别疲劳。Kindle只能用来看书，不会在阅读时被各种信息打断，可以让我沉浸在阅读中，专注阅读，并且不论是英语还是日语，都可以在Kindle中找到靠谱的词典。能通过软件自动化地将RSS订阅的文章推送到Kindle里，方便阅读大佬的推文。我上班的地方离住的地方也是特别远，所以在地铁上或者公交车上掏出Kindle来看书对我来说也是个很好的选择，我本身不是手机重度患者，没有特别多需要看的信息需要回复的信息，所以在地铁公交上看手机除了听音乐听播客就只能发呆了。省钱，Kindle本身不便宜，但是用kindle看书，其实一年下来省了不少买书的钱。&emsp;&emsp;关于Kindle对我来说体验到的优点其实还有挺多的，我也不一一列举了，网上对Kindle描述的优点比我丰富的多许多。二、Kindle的缺点&emsp;&emsp;说完优点再说说我对它的不满的地方:响应速度，我的Kindle paperwhite 3使用起来还是很明显的有卡顿的现象，而且切换页面响应的速度也慢没有自动换页的功能(越狱对我来说还是算了吧，不想整太多稀奇古怪的)，不能满足我的懒癌。记笔记的功能对我来说不是特别便捷高效。不能自定义屏保，听说越狱后是可以的。&emsp;&emsp;缺点其实只是针对我个人的体验，不吹不黑，纯粹是个人的感受。三、为什么我还是推荐你买Kindle&emsp;&emsp;推荐你看看知乎的：后悔买Kindle了吗？&emsp;&emsp;对我来说，我的回答也是不后悔，至少我买回来后没让它吸尘，读书其实也是对自己最好的投资，在这个生活节奏特别快的时代，偶尔让自己沉浸下来阅读也是个很好的体验。&emsp;&emsp;其实我当时也是拿着自己的第一份工资咬咬牙买下来的，在此这前也有看到不少的人在地铁公交上拿着Kindle在阅读，最让我下决心买，其实是当时我从学校寄书回去，可能那几天下雨，收到的时候很多书都被水浸湿了，心情十分不美好，快递费也贵。后面物色了好久才忍痛买的。&emsp;&emsp;在后面的时候中，越用越顺心，看大部分书籍就用Kindle，专业书籍我还是选择看纸质书。&emsp;&emsp;最后，其实你买不买Kindle对我没影响，哈哈哈，本身这篇文章不是推广的，我最想说的还是多看书，阅读书籍真的是对自己是相当有益的投资。至于读书的工具的选择，还是要靠自己来选择，如果真的有意向购买Kindle，一定要买有背光的，其他的自辩就好了。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PADSVX.2安装及破解]]></title>
    <url>%2F2019%2F09%2F25%2FPADSVX-2%E5%AE%89%E8%A3%85%E5%8F%8A%E7%A0%B4%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[本站迁移到 新博客，不再维护该站。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;阅读本文，大约需要3分钟一、前言&emsp;&emsp;在工作上，经常有用 PADS9.5 打不开 .PCB 文件的情况，总是提示“作业与当前版本的程序不兼容”的情况，原因有可能是对方用的高版本的 PADS ，既然这样，我们就在同一台电脑上来安装 PADS9.5 和 PADSVX.2 吧~二、PADS9.5 安装和破解&emsp;&emsp;PADS9.5的安装和破解可以参考我之前的博客： &lt;PADS9.5安装及破解&gt; ，这里就不再多讲。三、PADSVX.2 安装3.1 下载&emsp;&emsp;安装之前,我们要先把相应的安装包给下载下来，可以 &lt;点击,网盘链接&gt;密码: 9axk,安装相应软件及破解工具.3.2 安装&emsp;&emsp;打开下载好的目录,把三个压缩包都解压,这里我已经解压好了,&emsp;&emsp;解压完毕后,打开 PADSVX.2_ESDM 文件夹,找到 PADSVX.2_mib.exe ,右键以管理员身份运行,&emsp;&emsp;然后我们等待安装程序启动，可能会有点慢,在安装窗口中我们点击’下一步’,&emsp;&emsp;点击修改，先设置路径等&emsp;&emsp;我们先配置下需要安装的东西,这里点击 Product Selection ,如果单纯画板就勾选我框起的这些就可以了~&emsp;&emsp;然后,我们选择Target Path,选择要安装的目录,这里我安装在D盘,这里需要注意一点，如果你有安装PADS9.5的话，最好放在另外一个盘，或者区分开两个文件，后面也方便切换.&emsp;&emsp;在最后的一个选项PADS Projects Path中选择PADS工程路径,选择好了路径后,我们点击’完成’,&emsp;&emsp;确认无误后,我们点击’安装’,&emsp;&emsp;等到安装完毕后,我们选择at a later time，不着急哈，我们还有Logic没安装呢。&emsp;&emsp;打开 PADSLogicVX.2_ESDM 文件夹,找到 PADSLogicVX.2_mib.exe,同样右键以管理员身份运行,&emsp;&emsp;然后我们等待安装程序启动，在安装窗口中我们点击’下一步’,&emsp;&emsp;点击修改，&emsp;&emsp;配置需要安装的东西,这里点击 Product Selection&emsp;&emsp;然后,我们选择Target Path,选择要安装的目录,和上面步骤的路径一样就可以了&emsp;&emsp;配置好后点击完成,后点击安装就可以了,安装完成后同样点击at a later time就可以了。3.3 破解&emsp;&emsp;我们打开解压MentorCrackMaserV2_0_1-MentorCrackMasterV2的目录,找到MentorCrackMaster.exe,双击运行。&emsp;&emsp;找到我们安装PADS的根目录，这里我刚才安装在D盘,所以D盘里直接选中该路径就可以了，后点击破戒等待破解成功就可以了。破解成功会显示成功界面.四、PADS9.5 和 VX 切换使用&emsp;&emsp;当你电脑同时安装了 PADS9.5 和 VX 的话，是没办法兼容两款软件同时使用的。这个时候我们需要另一个软件来切换这两款软件，&emsp;&emsp;首先，我现在电脑上的.sch和.pcb 用的是 PADS9.5，那么我现在想换成VX来使用的话，我们需要打开MGC PCB Release Switcher,在开始菜单中找到Mentor Graphics PCB Admin..中的 MGC PCB Release Switcher 软件。&emsp;&emsp;打开后，&emsp;&emsp;切换完成后，会显示&emsp;&emsp;切换后的效果,&emsp;&emsp;到这里切换的基本操作就完成了。五、结语&emsp;&emsp;安装和破解参考了&lt;吴川斌的博客&gt;&emsp;&emsp;如果有出错的地方希望能帮我指出来，我会一一改正，感激不尽~！]]></content>
      <categories>
        <category>软件安装</category>
      </categories>
      <tags>
        <tag>软件安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Keil软件配置]]></title>
    <url>%2F2019%2F09%2F03%2FKeil%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[本站迁移到 新博客，不再维护该站。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;阅读本文，大约需要8分钟一、前言&emsp;&emsp;所有操作都是在 Keil5.14.2 版本上进行，其它版本的会有些差异，不过很多基本都是一样的。二、配置2.1 Keil5 的安装&emsp;&emsp;keil5的安装可以参考我之前的文章：【MDK5环境安装与建立工程模板】2.2 代码自动补全&emsp;&emsp;在工具栏中找到小扳手图标或者在菜单栏中打开 Edit-Configuration ，打开后点击 Text Completion 找到 Symbols after x Characters ，勾选并填入你需要在输入第几个字符后开启补全提示。&emsp;&emsp;这里我设置了输入三个字符后补全，2.3 添加注释模板&emsp;&emsp;同样在工具栏中找到小扳手图标或者在菜单栏中打开 Edit-Configuration ，同样的打开后点击 Text Completion 找到 Templates ，这里拿 if 来举例，在 Templates 窗口中，新增一个 if ，名字可以根据需要来取，怎么方便怎么来，这里为了方便演示，给它设定为 if ，然后我们在下方 Text 框中对应的给 if 增加对应文本。1234if (|)&#123; &#125;这里需要注意的是，我在 if 判断框中加了 | ，代表着我们使用 if 这个注释模板时，光标会对应的到判断框中就不需要在点一次判断框来书写你的判断条件。&emsp;&emsp;设置好后，我们点 OK 保存，然后我们要怎么使用呢？&emsp;&emsp;我们在 Keil 的菜单栏中找到 View-Templates Window ，将它勾选，就会有相应的 Templates 窗口，根据自己方便拖到一个适合的地方，这里我拖到了我右下角来使用它。&emsp;&emsp;在 Templates 窗口双击刚才设置的 if， 我们设置好的关于 if 文本就会对应的出现在当前光标指向的位置，并且新的光标也会出现在判断框中。&emsp;&emsp;如果不想要通过窗口点击的方式，我们也可以记住自己设定的名字，例如 if 在没有其他 i开头的影响下，按快捷键 ctrl+shift+space(空格)来使用注释模板。快捷键的使用可以参考官网给出的说明2.4 Editor 编辑设置&emsp;&emsp;在工具栏中找到小扳手图标或者在菜单栏中打开 Edit-Configuration-Editor ，将这一块分为五部分来设置，分为General Editor Settings、Function Display、Look &amp; Feel、File &amp; Project Handing、C/C++ &amp; ASM Files &amp; Other Files五个部分。2.4.1 General Editor Settings&emsp;&emsp;Encoding: 这里是设置我们的Keil的编码，一般我们选择默认的 Dncode in ANSI 就可以了，但是如果你打开别人的工程，看到注释乱码很大情况都是编码问题，这个时候修改你的编码为 Chinese GB2312(Simplified) 可以解决乱码的问题，当然不一定所有乱码都是编码的问题。&emsp;&emsp;Auto Indent: 这里是我们换行时自动缩进对齐的功能。推荐使用 Smart 灵活对齐。&emsp;&emsp;&emsp;&emsp;None: 不对齐，光标每次都在换行的最前面&emsp;&emsp;&emsp;&emsp;Smart: 灵活对齐。包含大括号自动对齐。&emsp;&emsp;&emsp;&emsp;Block: 光标对齐与前一行&emsp;&emsp;Virtual Spaces、View White Space、View End of Line,分别是光标可以指在任意位置、用·显示空格、在行尾显示换行符，这三种都不推荐勾选。2.4.2 Function Display&emsp;&emsp;这边的设置主要对应的是 View-Functions Window。&emsp;&emsp;Display Modules:勾选表示以模块的方式显示函数，不勾选则以函数名的方式显示，这个选项主要对应另外两个选项。&emsp;&emsp;Scan function names in project files:浏览工程项目中所有的函数。&emsp;&emsp;Scan function names in current editor files:浏览当前项目打开的文件的函数。&emsp;&emsp;这边我推荐都勾选上，以模块的方式显示工程中所有的函数，方便在各个项目文件中的.c中快速定位到你的函数的位置，当然如果你没有看 Functions Window 的习惯也可以不勾选。2.4.3 Look &amp; Fell&emsp;&emsp;Show Message Dialog during Find:在查找时显示消息对话框，勾选后，使用 Ctrl + F 查找工程中的内容时，如果搜索不到，会相应的提示消息框告知你当前文件或工程中没有你搜索的东西。&emsp;&emsp;Highlight Current Line:勾选上后光标选中的那一行会高亮。&emsp;&emsp;Highlight matching and mismatched braces:高亮显示匹配和不匹配括号。&emsp;&emsp;Print with syntax coloring:打印语法颜色。&emsp;&emsp;Colored Editor Tabs:启用或禁用文件名称标签的颜色。这个勾选上后你打开的文件的标签会有颜色，如果不勾选则默认白色。&emsp;&emsp;这边我推荐也是全部勾选，都是对整体编程效果有很好的帮助。2.4.4 File &amp; Project Handling&emsp;&emsp;Create Backup files(*.BAK):创建备份文件，后缀.BAK。&emsp;&emsp;Automatic reload of extemally modified files:自动加载(不提示)修改过的文件。&emsp;&emsp;Save Project before entering Debug:进入调试之前保存工程项目。&emsp;&emsp;Save Files before entering Debug:进入调试之前保存所有文件。&emsp;&emsp;Auto save modified File every x Minutes:每x分钟自动保存文件。&emsp;&emsp;这里我自己是全部都不勾选的，创建备份文件有点鸡肋，自动加载修改过的文件则十分的不安全，而每x分钟自动保存文件对我这种稍微改动一点代码都要经常编译的人来说，就没什么特别需求。2.4.5 C/C++ Files &amp; ASM Files &amp; Other Files&emsp;&emsp;&emsp;&emsp;Use syntax coloring:使用语法颜色，这个最好勾选，如果不勾选，就不会高亮关键词等。&emsp;&emsp;&emsp;&emsp;Insert spaces for tabs:Tab键插入空格&emsp;&emsp;&emsp;&emsp;Tab size x:Tab缩进x格&emsp;&emsp;&emsp;&emsp;Show Line Numbers:显示行数&emsp;&emsp;&emsp;&emsp;Use monospaced Font:使用等宽字体&emsp;&emsp;&emsp;&emsp;Open with Outlining:打开概述&emsp;&emsp;推荐勾选Use syntax coloring、设置Tab size 4、Show Line Numbers、Use monospaced Font、Open with Outlining2.5 Colors &amp; Fonts 设置&emsp;&emsp;这个是关于 Keil 字体大小、颜色，背景色等字体和颜色的配置。2.5.1 输入光标闪烁和当前行颜色&emsp;&emsp;All Editors - Caret Line - Font中修改 Foreground 可以修改在输入时光标闪烁的颜色， 而修改 Backgroud 可以修改在选中的输入行的颜色。&emsp;&emsp;举个例子，我这边修改前景色 Foreground 为浅蓝色，修改背景色 Backgroud 为浅灰色，实际效果：2.5.2 选中后光标闪烁和选中行时的颜色&emsp;&emsp;All Editors - Text Selection - Font中修改 Foreground 可以修改在选中代码时光标闪烁的颜色， 而修改 Backgroud 可以修改被选中的代码的颜色。&emsp;&emsp;同样的举个例子，我这边修改前景色 Foreground 为浅蓝色，修改背景色 Backgroud 为浅灰色，实际效果(灰色效果可能看不清楚)：2.5.3 背景色&emsp;&emsp;C/C++ Editor files - Text - Font中修改 Backgroud 可以修改背景的颜色2.5.3 字体大小、字体颜色、字体风格&emsp;&emsp;C/C++ Editor files - Element中可以设置个元素的字体大小颜色等，具体的设置都是根据不同元素的需求来设置。例如:&emsp;&emsp;我们可以根据需求来修改适合自己的编程环境。2.6 User Keywords 设置&emsp;&emsp;User keywords 是给用户自定义设置关键字的接口，在 Text File Types: 中 C/C++Editor files 添加关键词 FALSE 和 TRUE 实现的效果:设置：不设置：&emsp;&emsp;关键字显示的颜色则是在前面设置的。2.7 Shortcut Keys 设置&emsp;&emsp;Shortcut Keys可以用来修改快捷键，这里其实默认设置就可以了，绝大多数的快捷键符合我们的使用。我这里稍微修改了一些快捷键，如：&emsp;&emsp;选中行注释，我修改为了 ctrl + `&emsp;&emsp;取消选中行注释我修改为了 alt + `&emsp;&emsp;F7，用来编译。 F8，用来下载：2.8 Text Completion 设置&emsp;&emsp;这一块主要是添加注释模板和代码补全的，上面注释模板已经说过了，这里说说代码补全的：&emsp;&emsp;代码补全的重要性很高，推荐勾选。2.9 Other 设置&emsp;&emsp;other 这边可以设置是否开启软件启动界面等，根据需求来设置你想要的功能，具体看图吧&emsp;&emsp;勾选 Show splash screen 效果：三、插件keil5的插件可以参考我之前的文章：【Keil5代码格式化工具-Astyle】]]></content>
      <categories>
        <category>stm32</category>
      </categories>
      <tags>
        <tag>stm32</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【规范代码】Keil5代码格式化工具-Astyle]]></title>
    <url>%2F2019%2F08%2F12%2F%E3%80%90%E8%A7%84%E8%8C%83%E4%BB%A3%E7%A0%81%E3%80%91Keil5%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%B7%A5%E5%85%B7-Astyle%2F</url>
    <content type="text"><![CDATA[本站迁移到 新博客，不再维护该站。一、前言&emsp;&emsp;在用 Keil5 编写程序的时候，很多情况要参考别人写的程序来完成开发，在这过程中，看到了很多代码编写风格不一、代码编写不规范的情况。有时候看的头都大了，在一次偶然的情况下，认识了 Astyle 这一代码格式工具，就根据帖子上的教程配置在了 Keil 上，后面在使用的过程中，发现这款插件的高效性，所以特意拿出来分享。二、Astyle2.1 Astyle 官网&emsp;&emsp;Astyle官网2.2 Astyle 介绍&emsp;&emsp;我直接搬官网两句话来介绍，官网的介绍已经十分详细了，文档等信息都可以在官网上获取到。&emsp;&emsp;Artistic Style is a source code indenter, formatter, and beautifier for the C, C++, C++/CLI, Objective-C, C# and Java programming languages.&emsp;&emsp;Artistic Style是 C, C++, C++/CLI, Objective-C, C# 和 Java 等编程语言的代码缩进器、格式化器和美化器。&emsp;&emsp;Artistic Style是适用 C, C++, C++/CLI, Objective-C, C# 和 Java 等编程语言的免费、快速和小型自动格式化软件。2.3 Astyle 下载&emsp;&emsp;进入官网,在官网下方点击 Download 进入下载页面.&emsp;&emsp;下载页面直接下载最新版本即可.&emsp;&emsp;等待弹出下载后保存到你的电脑.2.4 Astyle 保存&emsp;&emsp;Astyle 下载完后，根据自己的需求和方便，解压并保存好就可以了。这里我是直接丢在了 keil5 的根目录下。三、Keil5 增加 Astyle 插件3.1 Keil5 使用 Astyle 效果&emsp;&emsp;使用前:&emsp;&emsp;使用后:3.2 Keil5 配置 Astyle&emsp;&emsp;打开 Keil5 ,然后在菜单栏中找到 Tools-Customize Tools Menu...&emsp;&emsp;打开后,增加两个内容,分别命名为:Astyle All FilesAstyle Current File&emsp;&emsp;命名可以自己需求，不一定和我一样。&emsp;&emsp;然后位置都选择你解压 Astyle 文件中 bin 文件夹下的 Astyle.exe&emsp;&emsp;在 Arguments 参数中对应填入:Astyle All Files-n &quot;$E*.c&quot; &quot;$E*.h&quot;Astyle Current File-n !E&emsp;&emsp;如图:&emsp;&emsp;设置好后我们点 OK 应用。3.3 Keil5 使用 Astyle 格式代码&emsp;&emsp;配置好后，我们可以在Tools-Customize Tools Menu...中看到我们新增加的两个自定义工具。&emsp;&emsp;格式化整个工程的 .c 与 .h 文件就选择 Astyle All Files。&emsp;&emsp;格式化当前文件则选择 Astyle Current File.&emsp;&emsp;格式化可以在 keil 的输出窗口看到格式情况。3.4 关于配置参数上的解释我们在 keil5 中填入了两行参数值：Astyle All Files-n &quot;$E*.c&quot; &quot;$E*.h&quot;Astyle Current File-n !E-n，格式化文件时，新的缩进的文件将保留原始文件，创建原始文件的副本，并在原始文件名后附加 .orig ，可以通过 -n 来取消设置备份副本。&quot;$E*.c&quot; &quot;$E*.h&quot;,$E是 Keil 的指令，表示工程内的全部文件，加上 .c 与 .h ，表示工程内 .c 文件与 .h 文件，Astyle 也会只格式化工程里的全部的 .c 与 .h 文件。!E,!E 是 Keil 的指令，表示当前文件, Astyle 在操作时就只格式化当前的文件。四、Astyle 的其他配置4.1 括号格式化风格&emsp;&emsp;具体的可以参照 Astyle文档,不过多叙述。4.1.1 allman 风格--style=allman / --style=bsd / --style=break / -A1Allman style uses broken braces.12345678910int Foo(bool isBar)&#123; if (isBar) &#123; bar(); return 1; &#125; else return 0;&#125;4.1.2 java 风格--style=java / --style=attach / -A2Java style uses attached braces.1234567int Foo(bool isBar) &#123; if (isBar) &#123; bar(); return 1; &#125; else return 0;&#125;4.1.3 kr 风格--style=kr / --style=k&amp;r / --style=k/r / -A3Kernighan &amp; Ritchie style uses linux braces. Opening braces are broken from namespaces, classes, and function definitions. The braces are attached to everything else, including arrays, structs, enums, and statements within a function.Using the k&amp;r option may cause problems because of the &amp;. This can be resolved by enclosing the k&amp;r in quotes (e.g. –style=”k&amp;r”) or by using one of the alternates –style=kr or –style=k/r.12345678int Foo(bool isBar)&#123; if (isBar) &#123; bar(); return 1; &#125; else return 0;&#125;4.1.4 其他&emsp;&emsp;还有很多的风格,可以在对应的文档看，总共有15种风格任君挑选，如 python、google、linux 风格等。&emsp;&emsp;因为我用 Keil 开发是 C 语言，所有我选了 A1 的风格，所以相应的在 Keil 上我就配置了:-n -A1 &quot;$E*.c&quot; &quot;$E*.h&quot;&emsp;&emsp;不生成副本，用 A1 风格，来格式化整个工程的 .c 与 .h 文件。4.2 格式化缩进长度4.2.1 空格缩进&emsp;&emsp;这里我就不在截图了，具体的可以看文档，默认我们不配置缩进选项的话，默认是4个空格，如果你想要更改缩进的空格长度，你可以通过:--indent=spaces / --indent=spaces=# / -s#&emsp;&emsp;-s4，就是缩进 4 个空格，那么相应的，要改缩进 x 个空格就更改 -sx 就可以了.4.2.2 制表符缩进&emsp;&emsp;同上，--indent=tab / --indent=tab=# / -t / -t#&emsp;&emsp;-t4，就是缩进 4 个制表符，那么相应的，要改缩进 x 个制表符就更改-tx就可以了。4.2.3 其他&emsp;&emsp;还有另外两种缩进方式，我觉得很少使用，就不列举了，有兴趣了解同样的访问官方文档即可。4.3 其他&emsp;&emsp;还有许多格式化的形式，我也不多加叙述，例如缩进’switch’块、’case’块、注释、’class’和’struct’块、预处理程序缩进等许许多多的格式化方式，官方文档列举的说明十分详细，针对自己需要的、想要的格式化需求，针对性的在文档中寻找并利用，制作一个自己的高效率工具。五、结语&emsp;&emsp;距离上一篇博客更新已经过了很久，不清楚自己是不是要继续坚持下去，在这段时间中，有几次想继续写博客，但是总是“提起笔又放下”，不清楚自己能写一个多好的博客，可能自己的开发经验不够多，也没什么好写的东西。但是我也不是很想放弃写博客，所以我也希望自己后面能经常写一些对自己有意义对他人有帮助的博客文章吧。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些实用的工具与软件]]></title>
    <url>%2F2018%2F12%2F20%2F%E4%B8%80%E4%BA%9B%E5%AE%9E%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7%E4%B8%8E%E8%BD%AF%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[本站迁移到 新博客，不再维护该站。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;前言最近访问我博客的人也越来越多了，想想似乎最近也没啥可以写的东西，所以就推荐一些我平时经常用的软件和工具吧，给大家提供参考~文本编辑Notepad++Notepad++ 顾名思义就是 windows 内置 Notepad 的增强版，它采用 C++ 编写，性能优秀，不仅小巧（完整安装包仅 4.78MB），功能众多，插件丰富，而且最关键的是“完全免费”！这一点比起 Editplus、UltraEdit、Sublime Text等其它文本处理软件来说，算是个大的卖点。支持语法高亮和颜色自定义可以添加插件更改格式、编码与符号可以给代码批量添加或取消注释….很多功能自行体会，看到身边好多人还在使用系统自带的记事本，功能小，使用十分不方便。使用Notepad++方便许多，博主自己也在用。下载地址Notepad++，进入官网，找到Download。UltraEditUltraEdit – 最强大的专业文本/十六进制编辑器！UltraEdit是世界上领先的，功能强大的，极具价值的文本编辑器、十六进制编辑器、HTML编辑器、PHP编辑器、Javascript编辑器、Perl 编辑器和程序编辑器。UltraEdit 是款全球功能一流的文本编辑软件，支持配置高亮语法和几乎所有编程语言的代码结构。内建英文单字检查，可同时编辑多个文件，编辑功能强大，具有代码提示、折叠、列操作等人性化功能。UltraEdit 体积大，功能强悍，很适合程序员使用，但我个人还是偏喜欢 Notepad++ 。这个体积稍微会大些，正版需要钱，所以我会提供个破解版，给需要的人，具体看后面结语~电子书阅读器calibrecalibre 是一个 “一站式” 的电子书解决方案，它可以全面满足你的电子书需求。calibre 是免费的，源代码开放，拥有跨平台的设计。它是一个完整的电子图书馆，包括图书馆管理，格式转换，新闻，将材料转换为电子书，以及电子书阅读器同步功能、整合进电子图书阅读器。界面与功能都十分强大，用来做看书最好不过了~calibre下载工具Readiris Corporate 17Readiris Corporate 是一款专业的文字OCR识别工具软件，其强大的识别能力和丰富的字库可使识别率达到98%以上。目前最新的Readiris Corporate 适用于Vista/Windows 7/Windows 10等系统平台，加入亚洲语言包后，简繁体中文、英文、德语、日韩……统统拿下！识别出来的图文混排照样能够遵照原来的版式不变。图文报纸的识别准确率不低于96%，日常公文的识别准确率不低于99%！还支持扫描仪的OCR识别，支持PDF文字识别、数码相机拍摄识别。拿来把扫描版的电子书，转成可以复制文字的电子书再好不过了，还支持其他格式的扫描，输出不同的格式。具体怎样下载破解，看后面结语。冰点文库素材下载器冰点文库下载器，下载文档利刃当之首选！免积分无需登录即可免费下载百度和豆丁文库。它支持百度、豆丁、丁香、畅享、MBALib、IT168、HP009、MAX、Book118、道客巴巴、金字塔医学、大桔灯等文库文档。支持多任务同时下载及断点续传，下载的文档与原始文档质量等同，最终生成高清晰PDF格式文档。这里缺点就在于只能生成高清晰的PDF格式文档，所以需要结合上面的OCR识别工具，配合起来用。结语上面那些没有链接需要破解的软件，我都放在网盘上了，网盘链接可以扫描下面微信公众号，回复“OCR”获取~。]]></content>
      <categories>
        <category>软件</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使用apktool反编译apk]]></title>
    <url>%2F2018%2F12%2F14%2F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8apktool%E5%8F%8D%E7%BC%96%E8%AF%91apk%2F</url>
    <content type="text"><![CDATA[本站迁移到 新博客，不再维护该站。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;前言因为一直使用别人的破解的 apk 相关软件，所以十分好奇是怎么做到的，查阅了一下然后做了个总结。安装apktool首先，我们去Apktool官网，按照步骤进行安装，1. 保存 脚本;2. 下载 apktool ，并且重命名为 apktool.jar ;3. 移动 apktool.bat 和 apktool.jar 到 C:\Windows ;最后在命令行输入 apktool 如下图，则成功，dex2jar与jd-gui首先，我们可以把你要反编译的apk(后缀是.apk)的，更改下格式为.zip，然后我们打开并解压它，因为我们需要的源代码就在里面。解压出来的文件中，我们需要对 classes.dex 进行操作。在这之前，我们需要下载dex2jar 与 jd-gui ，进入dex2jar官网，里面下载。我标红的这两个都需要，下载完解压出来，这里两个我都解压在D盘，接下来，我们把刚才说的 classes.dex 放入 D:\dex2jar-2.0里面，然后命令行执行如下：123cd D:\dex2jar-2.0cd D:d2j-dex2jar.bat classes.dex执行完，会出现 classes-dex2jar，这个就是我们需要的.jar文件。接下来要用到我们的另一个工具 jd-gui.exe，我们执行它，并且这就是我们需要的源代码。apktool使用可以查看源码之后，再修改相关代码，就需要我们刚才下载的 apktool 了，我的.apk放在桌面上通过cmd命令执行 apktool d app-debug.apk,填写你apk的名字，然后反编译。得到:最后,smali是源码编译后的地方，res是apk的资源文件，我们需要修改的就在这些里面，但是我们还需要理解smali语法才能修改，这里不再多说。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发-Apache服务器下载和安装]]></title>
    <url>%2F2018%2F11%2F27%2FAndroid%E5%BC%80%E5%8F%91-Apache%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8B%E8%BD%BD%E5%92%8C%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[本站迁移到 新博客，不再维护该站。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;前言在学习郭霖的《第一行代码》中有提到需要搭建Web服务器，书中用的也是推荐大家下载Apache，所以这一篇文章就来说如何下载与安装。下载Apache首先，我们进入Apache官网，在左侧找到Download。然后我们找到Files for Microsoft Windows(博主是win10系统)，下方找到Downloading Apache for Windows，找到ApacheHaus，进去后找到你需要的版本与匹配的位数，点击右侧的小图片下载，这样就把我们需要的Apache下载下来了。安装Apache我们把下载好的压缩包解压放到C盘或者其他盘(这里我解压在了D盘)，我们找到“D:\Apache24\conf“下的httpd.conf文件以文本的形式打开，找到Define SRVROOT &quot;xxx&quot;,将xxx修改为你存放解压下来Apache的位置，这里我是放在&quot;D:\Apache24&quot;，完成后保存，然后我们&quot;win+R&quot;输入cmd，通过cd命令进入Apache的bin文件夹，然后输入&quot;httpd.exe&quot; -k install -n apache，(双引号不能忽略)如果提示权限不足，右键开始菜单，打开命令提示符(管理员)，以管理员来安装，安装完成后，回到bin文件夹，打开ApacheMonitor.exe，在你的任务栏可以找到它的小图标，然后我们双击它可以打开窗口界面，然后我们点击start按钮开启服务，然后我们打开浏览器，访问&quot;http://localhost&quot;，看到如下界面，就成功了。]]></content>
      <categories>
        <category>Android</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发-注册登录与手机验证登录]]></title>
    <url>%2F2018%2F11%2F25%2FAndroid%E5%BC%80%E5%8F%91-%E6%B3%A8%E5%86%8C%E7%99%BB%E5%BD%95%E4%B8%8E%E6%89%8B%E6%9C%BA%E9%AA%8C%E8%AF%81%E7%99%BB%E5%BD%95%2F</url>
    <content type="text"><![CDATA[本站迁移到 新博客，不再维护该站。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;效果图前言这篇主要讲如何通过数据库添加用户注册账户并且验证账户并且登录，还可以通过手机接收验证码登录。准备登陆 MOB官网 注册账户，注册好后登录，进入后台，并且我们添加一个应用。应用名称根据个人喜好。这里我随便命名了个11应用，这里我们进入概况。这里我们记录一下应用Appkey与App Secret，后面我们会用到，并且我们开启短信验证功能。弄完后，我们回到 MOB官网 进入下载中心。然后我们下载短信验证功能的包。我是通过离线下载的SDK包，然后解压出我们需要的东西[路径(sms/SMSSDK/SMSSDK/libs)]然后解压这4个jar包。到这里，要准备的东西基本全了，有漏的后面再补充。建立工程这里我就不多说了，新建一个标准的工程，然后开始添加我们需要的东西。并且将我们解压的4个jar包加进工程里。开始准备布局我们先把需要的布局准备好，actuvuty_main.xml我只放了个登录成功的显示。12345678910111213141516&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="登陆成功" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintRight_toRightOf="parent" app:layout_constraintTop_toTopOf="parent" /&gt;&lt;/android.support.constraint.ConstraintLayout&gt;登录界面布局文件logic_layout.xml十分简单，放置了几个Button与编辑框，编辑框下拉我用的是ListPopupWindow来显示。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="fill_parent" android:layout_height="fill_parent" android:background="@drawable/background" android:orientation="vertical"&gt; &lt;LinearLayout android:id="@+id/layout" android:layout_width="fill_parent" android:layout_height="50dp" android:layout_marginTop="50dp" android:layout_gravity="center_vertical" android:orientation="horizontal" &gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginLeft="30dp" android:text="账户：" /&gt; &lt;com.example.syydnrycx.sqlitelogin.Class.ClearEditText android:id="@+id/user_name" android:layout_width="220dp" android:layout_height="40dp" android:drawableLeft="@drawable/user_name" android:drawablePadding="6dp" android:hint="name_tip" android:singleLine="true" android:background="@drawable/myedit_style" &gt; &lt;requestFocus /&gt; &lt;/com.example.syydnrycx.sqlitelogin.Class.ClearEditText&gt; &lt;ImageButton android:id="@+id/user_btn_img" android:layout_width="wrap_content" android:layout_height="wrap_content" android:background="@drawable/lg_down" android:paddingRight="2dip" android:scaleType="fitXY" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width="fill_parent" android:layout_height="50dp" android:layout_gravity="center_vertical" android:orientation="horizontal" &gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginLeft="30dp" android:text="密码：" /&gt; &lt;EditText android:id="@+id/user_pass" android:layout_width="220dp" android:layout_height="40dp" android:background="@drawable/myedit_style" android:layout_marginLeft="5dp" android:hint="密码" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width="fill_parent" android:layout_height="50dp" android:layout_gravity="center_vertical" android:orientation="horizontal" &gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginLeft="30dp" android:text="手机：" /&gt; &lt;EditText android:id="@+id/ed_phone" android:layout_width="220dp" android:layout_height="40dp" android:layout_marginLeft="5dp" android:background="@drawable/myedit_style" android:hint="手机号" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width="fill_parent" android:layout_height="wrap_content" android:layout_gravity="center_vertical" android:orientation="horizontal" &gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginLeft="30dp" android:text="验证码：" /&gt; &lt;EditText android:id="@+id/ed_code" android:layout_width="100dp" android:layout_height="40dp" android:background="@drawable/myedit_style" android:layout_marginLeft="5dp" android:hint="验证码" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width="fill_parent" android:layout_height="wrap_content" android:layout_marginTop="10dp" android:orientation="horizontal" &gt; &lt;Button android:id="@+id/bt_login" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginLeft="80dp" android:background="@drawable/mybutton_style" android:text="登录" /&gt; &lt;Button android:id="@+id/bt_register" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginLeft="20dp" android:background="@drawable/mybutton_style" android:text="注册" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width="fill_parent" android:layout_height="wrap_content" android:layout_marginTop="10dp" android:orientation="horizontal" &gt; &lt;Button android:id="@+id/bt_getphonecore" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginLeft="60dp" android:background="@drawable/mybutton_style" android:text="获取验证码" /&gt; &lt;Button android:id="@+id/bt_corelogin" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginLeft="20dp" android:background="@drawable/mybutton_style" android:text="验证码登录" /&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt;注册界面布局文件register_layout.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="fill_parent" android:layout_height="fill_parent" android:orientation="vertical" &gt; &lt;LinearLayout android:layout_width="fill_parent" android:layout_height="50dp" android:layout_gravity="center_vertical" android:layout_marginTop="20dp" android:orientation="horizontal" &gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginLeft="30dp" android:text="帐号：" /&gt; &lt;EditText android:id="@+id/usernameRegister" android:layout_width="220dp" android:layout_height="40dp" android:background="@drawable/myedit_style" android:layout_marginLeft="5dp" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width="fill_parent" android:layout_height="50dp" android:layout_gravity="center_vertical" android:orientation="horizontal" &gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginLeft="30dp" android:text="密码：" /&gt; &lt;EditText android:id="@+id/passwordRegister" android:layout_width="220dp" android:layout_height="40dp" android:background="@drawable/myedit_style" android:layout_marginLeft="5dp" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width="fill_parent" android:layout_height="wrap_content" android:layout_marginTop="10dp" android:orientation="horizontal" &gt; &lt;Button android:id="@+id/Register" android:layout_width="match_parent" android:layout_height="wrap_content" android:background="@drawable/mybutton_style" android:text="注册" /&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt;javajava文件我会挑些重要的解释，剩余我觉得无关紧要的，大家可以在我的Github上下载下来看。数据库建立 DatabaseHelper.java1234567891011121314151617public class DatabaseHelper extends SQLiteOpenHelper &#123; static String name="user.db"; static int dbVersion=1; public DatabaseHelper(Context context) &#123; super(context, name, null, dbVersion); &#125; //只在创建的时候用一次 public void onCreate(SQLiteDatabase db) &#123; String sql="create table user(id integer primary key autoincrement,username varchar(80),password varchar(80))"; db.execSQL(sql); &#125; //升级 public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123; &#125;&#125;登录、注册、获取ListPopupWindow显示账户 UserService.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class UserService &#123; private ArrayList&lt;String&gt; usernameList = new ArrayList&lt;&gt;(); private DatabaseHelper dbHelper; private String s = null; public UserService(Context context)&#123; dbHelper=new DatabaseHelper(context); &#125; //登录用 public boolean login(String username,String password)&#123; SQLiteDatabase sdb=dbHelper.getReadableDatabase(); String sql="select * from user where username=? and password=?"; Cursor cursor=sdb.rawQuery(sql, new String[]&#123;username,password&#125;); if(cursor.moveToFirst()==true)&#123; cursor.close(); return true; &#125; return false; &#125; //注册用 public boolean register(User user)&#123; //用getReadable和getWriteable都可以创建或者打开一个数据库并返回一个可对数据库进行读写操作的对象，当数据库满R可以只读，W会报错 SQLiteDatabase sdb=dbHelper.getReadableDatabase(); String sql="insert into user(username,password) values(?,?)"; Object obj[]=&#123;user.getUsername(),user.getPassword()&#125;; sdb.execSQL(sql, obj); return true; &#125; public ArrayList&lt;String&gt; getAll() &#123; SQLiteDatabase sdb=dbHelper.getReadableDatabase(); //查询获得游标 Cursor cursor = sdb.query ("user",null,null,null,null,null,null); //判断游标是否为空 if(cursor.moveToFirst()) &#123; //遍历游标 do&#123; //获得用户名 usernameList.add(cursor.getString(1)); &#125;while(cursor.moveToNext()); cursor.close(); &#125; return usernameList; &#125;&#125;主要的登录逻辑与手机验证获取123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245public class LoginActivity extends Activity implements View.OnClickListener&#123; private ArrayList&lt;String&gt; usernamelList; private Button bt_login,bt_register,bt_getphonecore,bt_corelogin; private ImageButton image_btn; private EditText edit_username; private EditText edit_password; private EditText edit_phone; private EditText edit_cord; private UserService uService = null; private ListPopupWindow listPopupWindow; private String phone_number; private String cord_number; EventHandler eventHandler; private boolean coreflag=true; private Context context; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.logic_layout); initViews(); sms_verification(); &#125; private void initViews() &#123; bt_login=(Button) findViewById(R.id.bt_login); bt_register=(Button) findViewById(R.id.bt_register); bt_getphonecore=(Button) findViewById(R.id.bt_getphonecore); bt_corelogin=(Button) findViewById(R.id.bt_corelogin); image_btn=(ImageButton)findViewById(R.id.user_btn_img); edit_username=(EditText) findViewById(R.id.user_name); edit_password=(EditText) findViewById(R.id.user_pass); edit_phone=(EditText)findViewById(R.id.ed_phone); //你的手机号 edit_cord=(EditText)findViewById(R.id.ed_code);//你的验证码 bt_login.setOnClickListener(this); bt_register.setOnClickListener(this); bt_getphonecore.setOnClickListener(this); bt_corelogin.setOnClickListener(this); image_btn.setOnClickListener(this); uService = new UserService(LoginActivity.this); usernamelList = uService.getAll(); &#125; protected void onDestroy() &#123;//销毁 super.onDestroy(); SMSSDK.unregisterEventHandler(eventHandler); &#125; protected void onResume() &#123; super.onResume(); usernamelList.clear(); //从注册返回时清除usernamelList usernamelList = uService.getAll(); //更新注册的内容 &#125; private void showListPopulWindow() &#123; listPopupWindow = new ListPopupWindow(this); listPopupWindow.setAdapter(new ArrayAdapter&lt;String&gt;(this,R.layout.list_item, usernamelList));//用android内置布局，或设计自己的样式 listPopupWindow.setAnchorView(edit_username);//以哪个控件为基准，在该处以mEditText为基准 listPopupWindow.setModal(true); listPopupWindow.setOnItemClickListener(new AdapterView.OnItemClickListener() &#123;//设置项点击监听 @Override public void onItemClick(AdapterView&lt;?&gt; adapterView, View view, int i, long l) &#123; edit_username.setText(usernamelList.get(i));//把选择的选项内容展示在EditText上 listPopupWindow.dismiss();//如果已经选择了，隐藏起来 &#125; &#125;); listPopupWindow.show();//把ListPopWindow展示出来 &#125; //按钮点击事件 @Override public void onClick(View v) &#123;/* String phone_number=edit_phone.getText().toString();//1 String cord_number=bt_getcord.getText().toString().trim();//1*/ switch (v.getId())&#123; case R.id.bt_login://登录监听 String name=edit_username.getText().toString(); String pass=edit_password.getText().toString(); boolean flag=uService.login(name, pass); if(flag)&#123; Log.i("TAG","登录成功"); Intent intent=new Intent(LoginActivity.this,MainActivity.class); startActivity(intent); Toast.makeText(LoginActivity.this, "登录成功", Toast.LENGTH_LONG).show(); &#125;else&#123; Log.i("TAG","登录失败"); Toast.makeText(LoginActivity.this, "登录失败", Toast.LENGTH_LONG).show(); &#125; break; case R.id.bt_register://注册监听 Intent intent=new Intent(LoginActivity.this,RegisterActivity.class); startActivity(intent); break; case R.id.bt_getphonecore://获取验证码的ID if(judPhone())&#123;//去掉左右空格获取字符串，是正确的手机号 SMSSDK.getVerificationCode("86",phone_number);//获取你的手机号的验证码 edit_cord.requestFocus();//判断是否获得焦点 &#125; break; // 获取后要提交你的验证码以判断是否正确，并登陆成功 case R.id.bt_corelogin://登陆页面的ID if(judCord()) &#123;//判断验证码 SMSSDK.submitVerificationCode("86", phone_number, cord_number);//提交手机号和验证码 startActivity(new Intent(this,MainActivity.class)); &#125; coreflag=false; break; case R.id.user_btn_img://编辑框下拉监听 showListPopulWindow(); //调用显示PopuWindow 函数 break; &#125; &#125; private boolean judPhone() &#123;//判断手机号是否正确 //不正确的情况 if(TextUtils.isEmpty(edit_phone.getText().toString().trim()))//对于字符串处理Android为我们提供了一个简单实用的TextUtils类，如果处理比较简单的内容不用去思考正则表达式不妨试试这个在android.text.TextUtils的类，主要的功能如下: //是否为空字符 boolean android.text.TextUtils.isEmpty(CharSequence str) &#123; Toast.makeText(LoginActivity.this,"请输入您的电话号码",Toast.LENGTH_LONG).show(); edit_phone.requestFocus();//设置是否获得焦点。若有requestFocus()被调用时，后者优先处理。注意在表单中想设置某一个如EditText获取焦点，光设置这个是不行的，需要将这个EditText前面的focusable都设置为false才行。 return false; &#125; else if(edit_phone.getText().toString().trim().length()!=11)&#123; Toast.makeText(LoginActivity.this,"您的电话号码位数不正确",Toast.LENGTH_LONG).show(); edit_phone.requestFocus(); return false; &#125; //正确的情况 else&#123; phone_number=edit_phone.getText().toString().trim(); String num="[1][3578]\\d&#123;9&#125;"; if(phone_number.matches(num)) &#123; return true; &#125; else&#123; Toast.makeText(LoginActivity.this,"请输入正确的手机号码",Toast.LENGTH_LONG).show(); return false; &#125; &#125; &#125; private boolean judCord() &#123;//判断验证码是否正确 judPhone();//先执行验证手机号码正确与否 if(TextUtils.isEmpty(edit_cord.getText().toString().trim())) &#123;//验证码 Toast.makeText(LoginActivity.this, "请输入您的验证码", Toast.LENGTH_LONG).show(); edit_cord.requestFocus();//聚集焦点 return false; &#125; else if(edit_cord.getText().toString().trim().length()!=4)&#123; Toast.makeText(LoginActivity.this,"您的验证码位数不正确",Toast.LENGTH_LONG).show(); edit_cord.requestFocus(); return false; &#125; else&#123; cord_number=edit_cord.getText().toString().trim(); return true; &#125; &#125; public void sms_verification()&#123; //MobSDK.init(context, "28bc12fa236e4","44cb357655f252a8a75eac378b8283ad"); eventHandler = new EventHandler() &#123; public void afterEvent(int event, int result, Object data) &#123; Message msg=new Message();//创建了一个对象 msg.arg1=event; msg.arg2=result; msg.obj=data; handler.sendMessage(msg); &#125; &#125;; SMSSDK.registerEventHandler(eventHandler);//注册短信回调（记得销毁，避免泄露内存）*/ &#125; /** * 使用Handler来分发Message对象到主线程中，处理事件 */ Handler handler=new Handler()&#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); int event=msg.arg1; int result=msg.arg2; Object data=msg.obj; if (event == SMSSDK.EVENT_GET_VERIFICATION_CODE) &#123;//获取验证码成功 if(result == SMSSDK.RESULT_COMPLETE) &#123; //回调完成 boolean smart = (Boolean)data; if(smart) &#123; Toast.makeText(getApplicationContext(),"该手机号已经注册过，请重新输入",Toast.LENGTH_LONG).show(); edit_phone.requestFocus();//焦点 return; &#125; &#125; &#125; //回调完成 if (result==SMSSDK.RESULT_COMPLETE)&#123; if (event == SMSSDK.EVENT_SUBMIT_VERIFICATION_CODE) &#123;//提交验证码成功 Toast.makeText(getApplicationContext(), "验证码输入正确",Toast.LENGTH_LONG).show(); &#125; &#125;else &#123;//其他出错情况 if(coreflag)&#123; bt_getphonecore.setVisibility(View.VISIBLE); Toast.makeText(getApplicationContext(),"验证码获取失败请重新获取", Toast.LENGTH_LONG).show(); edit_phone.requestFocus(); &#125; else&#123; Toast.makeText(getApplicationContext(),"验证码输入错误", Toast.LENGTH_LONG).show(); &#125; &#125; &#125; &#125;;&#125;添加 Appkey 与 App Secret在AndroidManifest.xml中增加12&lt;meta-data android:name="Mob-AppKey" android:value="xxx"/&gt;&lt;meta-data android:name="Mob-AppSecret" android:value="xxx"/&gt;还要把需要的权限增加进去12345678910&lt;uses-permission android:name="android.permission.READ_CONTACTS" /&gt;&lt;uses-permission android:name="android.permission.READ_PHONE_STATE" /&gt;&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt;&lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" /&gt;&lt;uses-permission android:name="android.permission.ACCESS_WIFI_STATE" /&gt;&lt;uses-permission android:name="android.permission.INTERNET" /&gt;&lt;uses-permission android:name="android.permission.RECEIVE_SMS" /&gt;&lt;uses-permission android:name="android.permission.READ_SMS" /&gt;&lt;uses-permission android:name="android.permission.GET_TASKS" /&gt;&lt;uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" /&gt;完整的1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.example.syydnrycx.sqlitelogin"&gt; &lt;uses-permission android:name="android.permission.READ_CONTACTS" /&gt; &lt;uses-permission android:name="android.permission.READ_PHONE_STATE" /&gt; &lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt; &lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" /&gt; &lt;uses-permission android:name="android.permission.ACCESS_WIFI_STATE" /&gt; &lt;uses-permission android:name="android.permission.INTERNET" /&gt; &lt;uses-permission android:name="android.permission.RECEIVE_SMS" /&gt; &lt;uses-permission android:name="android.permission.READ_SMS" /&gt; &lt;uses-permission android:name="android.permission.GET_TASKS" /&gt; &lt;uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" /&gt; &lt;application android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:roundIcon="@mipmap/ic_launcher_round" android:supportsRtl="true" android:theme="@style/AppTheme"&gt; &lt;activity android:name=".Activity.LoginActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=".Activity.RegisterActivity"&gt; &lt;/activity&gt; &lt;activity android:name=".Activity.MainActivity"&gt; &lt;/activity&gt; &lt;activity android:name="com.mob.tools.MobUIShell" android:theme="@android:style/Theme.Translucent.NoTitleBar" android:configChanges="keyboardHidden|orientation|screenSize" android:windowSoftInputMode="stateHidden|adjustResize"/&gt; &lt;meta-data android:name="Mob-AppKey" android:value="xxx"/&gt; &lt;meta-data android:name="Mob-AppSecret" android:value="xxx"/&gt; &lt;/application&gt;&lt;/manifest&gt;结主要的注释在代码中都有体现，还有一些代码没有贴出来可以在我的Github上下载下来看。]]></content>
      <categories>
        <category>Android</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio adb shell 无法设置为超级用户的解决方法]]></title>
    <url>%2F2018%2F09%2F13%2FAndroid-Studio-adb-shell-%E6%97%A0%E6%B3%95%E8%AE%BE%E7%BD%AE%E4%B8%BA%E8%B6%85%E7%BA%A7%E7%94%A8%E6%88%B7%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[本站迁移到 新博客，不再维护该站。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;前言在学习郭霖著的《第一行代码》时，其中在 SQLite 数据库存储时要运用 adb shell 访问数据库文件时，无法设置权限为超级管理员权限，为此停滞了好久，后来上网查询后知道 Android7.0 虚拟机没有root权限。所以我们在 adb shell 执行命令 su 回应 not found 。解决既然 Android 7.0 虚拟机无法设置权限，那我们退而求其次使用 Android 6.0的虚拟机 就可以设置超级管理员权限。所以我们可以进入 Android Virtual Device Manager 新建一个虚拟机，点击 Create Virtual Device..，选择一个机型后我们点击 next，我们下载一个7.0以下的版本，这里我选择了一个 Android 6.0版本 的虚拟机，设置好后，我把我的 app 装在新的虚拟机上，并且在 cmd 上输入 adb shell，这时候我们可以看到从之前的 $：普通管理员，自动的变为 #：超级管理员。假如没有自动设置为 #：超级管理员的话我们可以通过 su 来设置。到此，设置权限的问题已经解决。]]></content>
      <categories>
        <category>Android</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Visual Studio Professional 2015安装]]></title>
    <url>%2F2018%2F09%2F04%2FVisual%20Studio%20Professional%202015%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[本站迁移到 新博客，不再维护该站。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Visual Studio Professional 2015安装下载首先，从我的网盘 密码: iycx，下载镜像文件。安装将下载好的.iso镜像文件解压:后双击解压的.exe文件，开始初始化安装:设置要安装的文件路径，这里我选择了D盘:接下来选择我们需要的功能，根据自己的需求选择:【Visual C++】是可选的，如果你希望用C++开发各种类型的应用程序，需要勾选它。【Visual F#】与【python工具】是可选的，开发Android应用程序时需要勾选。【windows和web开发】如果你希望在VS中使用与办公软件交互的功能时需要勾选，不做阐述。【Windows 8.1和Windows Phone 8.0/8.1工具】不推荐勾选，使用很少【常用工具和软件开发工具包】根据需要勾选确认自己需要的功能后点击下一步，再点击安装:安装时间漫长，可以冲杯茶休息一下。安装完毕后，选择开发环境，这里我选择 C#:等待环境初始化:完成后，界面弹出:破解打开菜单栏的帮助，点击注册产品:在右边栏显示试用期30天，填写秘钥: HMGNV-WCYXV-X7G9W-YCX63-B98R2显示如下，则破解OK。]]></content>
      <categories>
        <category>软件安装</category>
      </categories>
      <tags>
        <tag>软件安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PADS9.5安装及破解]]></title>
    <url>%2F2018%2F04%2F21%2FPADS9-5%E5%AE%89%E8%A3%85%E5%8F%8A%E7%A0%B4%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[本站迁移到 新博客，不再维护该站。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;前言好久没更新了,最近好忙好忙的,闲来无事,这一篇就说说怎样安装PADS9.5吧.PADS9.5安装下载安装之前,可以点击 密码: iycx,安装相应软件及破解工具.安装打开下载好的目录,解压里面的’PADS_9-5.part1’和’MentorCrackMaserV2_0_1’,这里我已经解压好了,解压完毕后,打开PADS_9-5文件夹,找到’PADS9.5_mib’,右键属性,在兼容性中勾选以管理员身份运行此程序,然后我们双击运行它,在安装窗口中我们点击’next’,然后点击’skip’,再点击’Agree,接下来,我们先配置下需要安装的东西,这里点击’Modify’,选择’Product Selection’,这里把全部勾选,除了最后的’Server Services’不勾选,然后,我们选择’Target Path’,选择要安装的目录,这里我默认安装在C盘,在最后的一个选项’PADS Projects Path’中选择PADS工程路径,这里我也默认,选择好了安装路径后,我们点击’Done’,确认无误后,我们点击’Install’开始安装,等到进度条走完后,我们选择’at a later time’,先破解后,我们在打开软件.这个时候,桌面就有了安装好的软件.破解我们打开解压’MentorCrackMaserV2_0_1’的目录,找到’MentorCrackMaster’,然后点击浏览,找到我们安装PADS的根目录,这里我刚才安装在C盘,所以C盘里直接选中该路径就可以了,如果你安装在其他盘,一样找到’MentorGraphics’这个目录,然后点击破戒,会弹出窗口,等待即可,破解成功会显示成功界面.修改软件语言我们打开Layout或者Logic其中一个软件,这里我的是中文界面,假设我想要英文界面,这里我们打开工具,找到’自定义’,在选项中,找到界面语言,修改为’English’,更改后会提示重启软件,我们关闭软件重新打开就好了,这个时候软件语言就变为英文的了.结语到这里,基本安装及破解都没有问题了.20190925 更新更新了 PADSVX.2 的安装和破解&lt;PADSVX.2安装及破解&gt;]]></content>
      <categories>
        <category>软件安装</category>
      </categories>
      <tags>
        <tag>软件安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MDK5环境安装与建立工程模板]]></title>
    <url>%2F2018%2F04%2F15%2FMDK5%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E5%BB%BA%E7%AB%8B%E5%B7%A5%E7%A8%8B%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[本站迁移到 新博客，不再维护该站。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;前言这一篇讲怎么安装MDK5环境与stm32f103zet6工程模板的建立,包含了软件安装,st-link驱动安装与工程模板建立.文章比较长,请细心看~.MDK5环境安装下载装软件之前,请先下载MDK5.14及相关的破解等软件.软件及破解软件 密码: iycx固件库安装 密码: iycx二个都要安装,缺一不可MDK5.14安装下载完软件后,就开始我们的安装,首先打开我们的软件目录,里面有MDK5和ST LINK驱动及教程.我们先打开MDK5文件夹,找到mdk514.exe,并双击打开它,弹出安装窗口,我们点击next,勾选I agree to all the tems of the preceding License Agreement 并点击next,选择安装的目录,可以在D盘等其他盘,这里我不改动,直接安装在C盘,安装在其他盘时不要改动安装的文件夹,直接修改盘符就行.比如我安装在D盘:请修改C:\Keil_v5 为D:\Keil_v5, 修改C:\Keil_v5\ARM\PACK为D:\Keil_v5\ARM\PACK避免不必要的麻烦.选择好安装目录后,我们点击next,在弹出来的,填写信息,这里随便填就可以了,填完点击next等待安装完成,进度条走完会弹出是否安装设备软件,这里点安装,安装完成后,取消勾选Show Release Notes并点击Finish在弹出来的窗口,关掉就可以了.到这里软件就装好了.MDK5.14破解在桌面Keil uVision5的快键方式中,右键属性,找到兼容性,勾选以管理员身份运行此程序,然后点击确定.然后我们运行软件,在左上角File中找到License Management..,打开它.先晾在一边冷静一下,找到我们MDK5安装包的位置,打开keygen文件夹,并运行keygen,我们复制keil5中的CID到keygan中的CID窗口里, 并选择ARM然后点击Gemerate,把生成的一段码复制到Keil5的LIC位置,点击Add LIC,出现了Expires:Oct 2020,恭喜你,程序已经破解OK了,MDKF1支持包安装还是打开MDK安装包的目录,找到Keil.STM32F1xx_DFP.1.0.5.pack双击它,在弹出来的窗口点击next,安装完成后,我们点Finsh,ST-LINK驱动安装还是在刚才下载的目录中,我们找到ST LINK驱动及教程\ST-LINK驱动\ST-LINK官方驱动中的dpinst_x86与dpinst_amd64,至于装哪个,看你的电脑是几位的来装就可以了,双击打开它,并点击next,安装设备软件,安装完后点击完成.这样ST-LINK的驱动也装好了.STM32f103ZET6工程模板建立打开下载的另一个F1固件库文件夹,先晾在一边,我们在桌面新建一个文件夹来存放工程,这里我命名Project_Demo,打开keil5,在上面找到Project-New uVision Project,点击它.把它命个名保存到刚才新建的文件夹中,这里我命名为Project,你可以命名一个相关你项目的名字也是可以的,保存后,在弹出的窗口中我们找到我们的芯片STM32F103ZE点击OK,并关掉接下来弹出的窗口,这个时候我们可以看一下我们的工程目录中多了几个文件,这里的Listings和Objects可以删除,后面我们把生成的文件保存到另外一个文件夹了,我们在工程模板中新建几个文件夹:USER:存放工程文件例如main、中断等STARUP:存放我们的启动文件和核心文件ST_LIB:存放官方库函数Output:存放我们的生成文件Prj:存放项目文件接下来,我们在ST_LIB中添加库函数文件,打开固件库目录,\Libraries\STM32F10x_StdPeriph_Drive\复制inc与src文件夹到ST_LIB中,`添加我们的启动文件和核心文件,\Libraries\CMSIS\CM3\CoreSupport中的core_cm3.c和core_cm3.h到STARUP中,再找到\Libraries\CMSIS\CM3\DeviceSupport\ST\startup\arm中的startup_stm32f10x_hd.s到STARUP中,在定位到\Libraries\CMSIS\CM3\DeviceSupport\ST中复制stm32f10x.h、system_stm32f10x.c、system_stm32f10x.h到USER文件中,定位到\STM32F10x_StdPeriph_Lib_V3.5.0\Project\STM32F10x_StdPeriph_Template中,复制main.c、stm32f10x_conf.h、stm32f10x_it.c、stm32f10x_it.h到USER中,回到keil5,右键Target1,点击Manage Project Items..,在Groups栏中删除Source Group 1,添加USER、STAUP、ST_LIB、Prj,点击USER,Add Files..添加main.c、stm32f10x_it.c、system_stm32f10x.c,点击STAUP,Add Files..选择显示所以文件类型,并把core_cm3.c与startup_stm32f10x_hd.s添加进来,点击ST_LIB,Add Files..添加ST_LIB中src的所有文件,Ctrl+A选中所有,添加到ST_LIB,只是src文件夹里的,不包括inc里面的文件.Prj先不添加,因为现在没有需要的项目文件需要添加,我们点击一个类似锤子的东西”魔术棒”,找到Output,Select Folder for Objects选中要输出编译生成文件的目录Output,最好把Create HEX file也勾上,因为如果你用串口来烧写程序,你就需要HEX文件了,点击OK,我们在打开一起魔术棒,找到C/C++,在Define栏中添加STM32F10X_HD,USE_STDPERIPH_DRIVER,最好复制过去,自己打错了就会引起不必要的麻烦,然后我们添加头文件,点击删除图标左边的新建,添加USER这个目录,在依次添加ST_LIB中的inc文件夹与STARUP文件夹,如图所示:确认无误后确定,然后我们删除main.c里面的所有代码,添加:1234567#include "stm32f10x.h"int main(void)&#123;&#125;然后我们点击左上方的编译,如果没有报错编译后的输出窗口应该是这样的:到了这里,工程模板就建立好啦,如果你写了你的项目文件,比如led.c与led.h你就可以把它放入Prj目录中,并在keil的Prj中添加.c文件,在魔术棒中的C/C++中添加led.h所在的目录.结语MDK环境与安装与模板的建立就完了,如果过程中有什么问题,可以在下方留言,只要细心按步骤来,是不会有问题的!~~]]></content>
      <categories>
        <category>stm32</category>
        <category>软件安装</category>
      </categories>
      <tags>
        <tag>stm32</tag>
        <tag>软件安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java开发环境安装及环境变量配置]]></title>
    <url>%2F2018%2F04%2F13%2FJava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E5%8F%8A%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[本站迁移到 新博客，不再维护该站。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;前言最近,开始教Java,发现很多人安装了Java后出现了各种问题,这里就对Java安装步骤及环境变量配置作详细的介绍.安装Java开发环境JDK下载首先,打开下载网站：www.oracle.com,根据箭头方向找到Java SE,进入页面后,在下方找到Download Java SE for Developers,并打开它打开后页面是这样的:这里要提醒一下,最好不要装Java最新的版本,因为新版本中环境变量和旧的不同,而且新版本配置后部分人反映配置后不能使用.所以这里我们向下找到Java SE 8u161/ 8u162,并点击JDK下面的DOWNLOAD,这里我选择的是Java SE Development Kit 8u162,选择适合你电脑的位,这里我的是64位,所以下载了64位的安装包.JDK安装根据上面的步骤,我们下载好了JDK的安装包后,我们打开安装包,后点击下一步进行安装,这里要注意的是：最好不要更改安装目录,因为部分安装到别的目录不会配置环境变量,所以为了不必要的麻烦,尽量不要更改安装目录.点击”下一步”后,程序就开始安装了,JDK安装完成后,会提示你是否安装JRE,同样的,我们不修改安装目录,直接下一步开始安装就行了安装完成后,我们点击关闭就可以了.到这里,你的Java开发环境算是安装成功了.接下来我们说一下如何配置JDK环境变量.JDK环境变量配置在资源管理器中,右击我的电脑,选择属性,在弹出来的系统面板中选择高级系统属性,在弹出来的系统属性中,我们打开环境变量.这里我们在系统变量中添加变量名: JAVA_HOME变量值: C:\Program Files\Java\jdk1.8.0_162接下来,在系统变量中寻找”Path”变量,如果不存在,则新建变量”Path”,如果存在,则选中编辑它.在变量值最前面,添加:%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;添加完后,确认,在系统变量中寻找”CLASSPATH”,和上面一样,如果存在则编辑,不存在则新建,变量名: CLASSPATH变量值: %JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;全部添加好后,我们点击确定,回到桌面,win+R输入cmd,打开cmd命令窗口,输入以下命令:`java -versionjavac -versionset JAVA_HOME`输出窗口如下信息,即为配置成功:结语配置环境变量最重要的是细心,如果少一个标点符号都有可能导致后面验证窗口信息失败,所以请准确的安装步骤来配置.]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[stm32AD采样滤波之中位值平均滤波]]></title>
    <url>%2F2018%2F04%2F13%2Fstm32AD%E9%87%87%E6%A0%B7%E6%BB%A4%E6%B3%A2%E4%B9%8B%E4%B8%AD%E4%BD%8D%E5%80%BC%E5%B9%B3%E5%9D%87%E6%BB%A4%E6%B3%A2%2F</url>
    <content type="text"><![CDATA[本站迁移到 新博客，不再维护该站。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;前言水温中,我们说到了为了防止AD波动使得送入表中查到的温度上下跳动,那么怎么坐到防止AD波动大呢,这就需要我们的滤波算法了.相信很多初学者,一开始学习ADC时,都是用的均值滤波，取十次值求平均,这种滤波方式如果AD跳动略快就会不精准,所以这里我提供了另一种滤波的方式.滤波算法滤波讲解先对AD取N次值(N为奇数),对AD采样值进行排序,然后去掉一个最大与一个最小，计算N-2个数据的算术平均值，这个值作为本次AD的实际采样值这个方法结合了普通均值滤波的优点,又在它的基础上提高了精度，通过排序去掉了最小与最大,但是在提高的精度的前提,是十分浪费CPU的.不过这对于stm32资源丰富的芯片来说,这个滤波方法不失为一个提升AD精度的方式.滤波算法12345678910111213141516171819202122232425262728293031#define N 13u16 Get_Adc_Average(u8 ch)&#123; u16 value_buf[N]; u16 temp; u8 count, i, j; for (count=0; count&lt;N; count++) &#123; value_buf[count] = Get_Adc(ch); delay_ms(5); &#125; for (j=0; j&lt;N-1; j++) //冒泡排序 &#123; for (i=0; i&lt;N-j-1; i++) &#123; if (value_buf[i] &gt; value_buf[i+1]) &#123; temp = value_buf[i]; value_buf[i] = value_buf[i+1]; value_buf[i+1] = temp; &#125; &#125; &#125; temp = 0; for (count=1; count&lt;N-1; count++) &#123; temp += value_buf[count]; &#125; return temp/(N-2);//把N次采样值按大小排列 ，取中间值为本次有效值&#125;结语滤波算法有很多种,这只是其中的一种,不同的滤波方式适用与不同的环境,所以怎么选择一个滤波方式,还是要根据使用的实际情况.]]></content>
      <categories>
        <category>stm32</category>
      </categories>
      <tags>
        <tag>stm32</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[stm32f030水温控制(完)]]></title>
    <url>%2F2018%2F04%2F13%2Fstm32f030%E6%B0%B4%E6%B8%A9%E6%8E%A7%E5%88%B6-%E5%AE%8C%2F</url>
    <content type="text"><![CDATA[本站迁移到 新博客，不再维护该站。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;前言前面的子模块的基本配置已经讲过了,这一篇算是完结篇了,本篇只讲大致如何实现各模块组合实现水温控制,程序子模块都已经有了,剩下的只是把子模块整合在一起,实现一个具体的功能.程序程序框架首先你得确保你的子模块单独运行时没有错误,可以实现单独的功能,如果连基本的独立工作的功能都无法实现,整合就谈不上了.框架讲解 再次提醒一下,一定要确保你每个子模块都能独立运行确保你的系统能有一个1s翻转1次的LED指示灯(确保程序在运行)通过定义变量获取AD值,输入滤波算法得到滤波后的AD值(确保精准)滤波后的AD最好尽量精准平稳,因为可以确保查表后温度跳动不会特别明显.EC11确认能通过左旋右旋控制设定的温度值,并且要保证EC11按键精准可控,并且将设定的温度与实际温度分别显示在数码管中.将获取的实际温度与设定温度传入pid算法,并且通过pid参数整定不断调整到系统最佳.将Pid的输出通过改变PWM实现控温效果.时间要求1.LED – 1S翻转(有两个指示灯,建议一个用来做系统运行指示灯,另一个调试用)2.AD采集 – 10ms-50ms采集一次.查表获取温度 – 30-60ms查一次表(使得数码管显示的实际温度不会跳变太快)对实际温度与设定温度进行运算送入数码管 – 300ms(同上,使得数码管跳变不会太快)数码管动态扫描 – 0.01ms扫描一次(确保数码管不会亮度太暗,或者人眼可以看见跳动)pid运算 – 建议直接放在while(反馈系统一直在线)模块整合建议通过上述框架一点点加入子模块,确保每次加入子模块后程序还能继续运行.通过程序框图,与每个模块执行认为的时间,基本可以实现控温,这里需要提醒的是,最好不要阻塞程序运行,否则效率会低.模块整合这边不会贴出代码,只给出了思路,至于怎么整合,只要稍微有C语言的基础,都能对程序逻辑做出很好的实现,程序子模块都确保可以运行,剩下的基本就是逻辑方面上的问题了.视频实际效果可参考：点击这儿点击这儿这里误差大概 -1 到 +1度之间.补充上面视频里,温度跳动稍微有些快,后来做了修改:1.之前是10ms采集AD,后来修正为500ms采一次AD.2.PID参数微调.比上面效果会更好,但是没法上传.结语看到这里,水温控制已经完结了,如果你有什么疑问可以评论问我,我看到会尽量回复的.]]></content>
      <categories>
        <category>stm32</category>
      </categories>
      <tags>
        <tag>stm32</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于stm32f030水温控制5]]></title>
    <url>%2F2018%2F04%2F13%2F%E5%9F%BA%E4%BA%8Estm32f030%E6%B0%B4%E6%B8%A9%E6%8E%A7%E5%88%B65%2F</url>
    <content type="text"><![CDATA[本站迁移到 新博客，不再维护该站。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;前言到这里,子模块已经写了4篇了,这一篇就对最为核心的pid做完介绍就开始简单讲模块整合了.pid分许多种,位置式pid、增量式pid、积分分离pid、抗积分饱和性pid、梯形积分pid、模糊Pid等等.P是比例,I是积分,D是微分.就我的理解,它是一个自动控制系统,我们核心的就是pid参数的整定,至于pid究竟是个什么东西.网上有一大把讲的比我透彻的资料,这里我就不献丑了.PIDpid算法的选择我大概用了C语音打印出来的表,从图里看位置型,上升的斜率比较平缓,适合水温上升的幅度,增量式的和位置式的接近,这里我没贴出图,所以我用的是位置式pid至于位置式和增量式如何选择,我是不知道从哪里看到的资料,说位置式适用于没有记忆性器件的环境,而增量式相反,而水温加热这边我只是控制固态继电器开关,没有记忆性的环境,所以我选择的是位置式Pid,并不是说只有位置式可以达到要求,增量式其实也是可以的至于如何选择,还需根据自己的实际情况来决定.pid实现首先,我们定义一个pid的结构体,并声明它.接下来,我们设置个函数初始化这些参数,初始化好了后,就是我们的核心算法了,pid参数整定老实说我也不太会,调整参数这边,我的建议是先不加入积分与微分,仅加入比例控制,直到系统可以到达你所设置温度,接下来过冲,振荡建议用串口打印后生成表格来调整积分与比例.参数整定这边,我能给出的建议就这些,毕竟我也是初学Pid.这里给出常用的口诀:参数整定找最佳，从小到大顺序查 先是比例后积分，最后再把微分加 曲线振荡很频繁，比例度盘要放大 曲线漂浮绕大湾，比例度盘往小扳 曲线偏离回复慢，积分时间往下降 曲线波动周期长，积分时间再加长 曲线振荡频率快，先把微分降下来 动差大来波动慢。微分时间应加长 理想曲线两个波，前高后低四比一 一看二调多分析，调节质量不会低补充忘了说了,我的是NTC采集的温度,所以需要配置AD采集与对NTC温度表对应.这里给出ADC配置NTC对应的温度表这里就不发了,根据自己实际的电压才能使得AD对应的温度更精准]]></content>
      <categories>
        <category>stm32</category>
      </categories>
      <tags>
        <tag>stm32</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于stm32f030水温控制4]]></title>
    <url>%2F2018%2F04%2F13%2F%E5%9F%BA%E4%BA%8Estm32f030%E6%B0%B4%E6%B8%A9%E6%8E%A7%E5%88%B64%2F</url>
    <content type="text"><![CDATA[本站迁移到 新博客，不再维护该站。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;前言这一篇,说一下水温加热方面,这里水温加热这边,我们用的是固态继电器,一端连接加热棒,一端连接单片机驱动MOS电路.从原理图可以看出,我们只要输出高低电平就可以实现水温加热,通过LED指示灯观察是否加热.既然用到了拉高拉低,既可以用周期性拉高拉低实现PWM,也可以使用定时器输出PWM,这里资源充足,所以用的是定时器配置PWM定时器PWM配置配置这边,在图片里,也给了相应注释配置方面可以根据自己实际需要去修改分频值与重装载值.补充配置好定时器后,我们如何通过实际来修改占空比，难道每次修改都要重新初始化一次吗?答案是不用的,stm32f0中库给出了修改占空比的函数,TIM_SetCompare4(TIMx, duty);TIM_SetCompare4 后面的4标示了通道,TIMx通过更改x可以选择TIM1,TIM2等定时器, duty则是你要传入的占空比,这与你的重装值有关这里还需强调,我用的是stm32f030K6,系统时钟为48M.PWM频率是由系统时钟除于你的分频值得到的,例如我设置分频值为2400则频率f = 48M / 2400 = 20000Hz = 20KHz,可以推算出计算周期为 = 1/20KHz = 0.00005s = 50us结语这一章配置定时器,十分简单的达到了加热的效果,如何达到水温控制,则要用到PID算法,这个后面再说.]]></content>
      <categories>
        <category>stm32</category>
      </categories>
      <tags>
        <tag>stm32</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于stm32f030水温控制3]]></title>
    <url>%2F2018%2F04%2F13%2F%E5%9F%BA%E4%BA%8Estm32f030%E6%B0%B4%E6%B8%A9%E6%8E%A7%E5%88%B63%2F</url>
    <content type="text"><![CDATA[本站迁移到 新博客，不再维护该站。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;前言上一篇,我们说到了旋转编码器EC11的实现,这篇我们讲一下数码管.首先,我的板上用到的数码管有两片,一片4位,分别用两个595驱动,节省IO口. 数码管用的是3461BS,共阳极的数码管,驱动数码管,只需把我们的段码与位通过595发送到数码管的管脚,原理简单,这里就不多说了. 数码管配置595连接芯片的IO分别是DIO-PB5 RCLK-PA15 SCLK-PB3,这里只要配置为推挽输出就可以了.数码管显示配置先看显示这边,传入参数L1,L2,L3,L4分别对应数码管4个位所要显示的段码,H代表选择显示的是第一块数码管还是第二块 0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80分别是位码最后把要显示的段码,通过函数传入. 把要写入数码管的数据,写入函数 _3461BS_Date(u8 date),送入数码管. 结语通过调用函数,我们可以实现静态显示,至于如何动态显示,我们后面再说. 最后贴上实物图:]]></content>
      <categories>
        <category>stm32</category>
      </categories>
      <tags>
        <tag>stm32</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于stm32f030水温控制2]]></title>
    <url>%2F2018%2F04%2F12%2F%E5%9F%BA%E4%BA%8Estm32f030%E6%B0%B4%E6%B8%A9%E6%8E%A7%E5%88%B62%2F</url>
    <content type="text"><![CDATA[本站迁移到 新博客，不再维护该站。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;前言承接上一篇的水温控制,这一篇我们把控制设定温度的旋转编码器EC11讲一下.EC11预备知识EC11旋转编码器是一种小型高精度旋转式编码器,在结构上,由编码器部分和按键部分组合而成,这里我用到了EC11A相和B相与一个按键.我们需要编写的就是如何判断旋转的方向与按键的检测.从图中我们可以看出,假设检测A相上升沿,我们只需判断B相的高低电平就可以知道旋转的是正向或是逆向,知道了如何检测,配置就方便多了,接下来我们讲一下如何配置.EC11配置时钟配置这边由于我的A相B相和按键所在IO都在PA上,所以我打开了GPIOA的时钟,由于需要映射中断管脚,所以开启了SYSCFG时钟.管脚配置这边,直接配置IO为上拉输入,这里有别与F1系列的我上一篇已经讲过了.这里就不多说了中断,要映射管脚,这里我用的是PA10,所以映射了中断线10,配置好中断,我们就只需要在中断函数里检测另一相的电平就可以了,这里我就不在多说了.最后设置一下中断优先级就可以了.按键配置按键的配置其实上面已经有了,这里我们讲一下如何检测按键,通常扫按键的方法都是延时10ms,但是这种方式延时,不一定能达到我们要的效果.所以这里我介绍一下状态机按键消抖的方式.通过上面的状态跳转,实现判断按键抬起、长按、连按,相比延时扫描按键的方法,好了很多.结语这里简单的讲了EC11AB相的检测以及按键的扫描方法,如果文中有哪些错误,希望你能给我发邮件告知,感激不尽.]]></content>
      <categories>
        <category>stm32</category>
      </categories>
      <tags>
        <tag>stm32</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于stm32f030水温控制1]]></title>
    <url>%2F2018%2F04%2F12%2F%E5%9F%BA%E4%BA%8Estm32f030%E6%B0%B4%E6%B8%A9%E6%8E%A7%E5%88%B61%2F</url>
    <content type="text"><![CDATA[本站迁移到 新博客，不再维护该站。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;前言这篇博客是基于我老师布置的项目”stm32f030水温控制”所写的,我会把每个模块的基本配置为大家进行讲解.好啦闲话不多说,进入我们的正题.LED和蜂鸣器的配置LED或者是蜂鸣器(BEEP)基本上是我们学习32的基础,配置这方面十分简单,所以我会简单的略过一些配置.我的板上LED和蜂鸣器与单片机相连的IO口有三个,分别是LED1-PA11 LED2-PA12 BEEP-PA0,接下来我们就说一下如何配置.首先,我们需要定义GPIO结构体与PA口的时钟,这里有别与F1系列的配置,F0PA口上的时钟是在AHB总线上,而F1PA口上的时钟是APB2,所以这里我们要区分一下,否则会报错.配置完时钟,我们就可以对IO口进行配置了,这里我设置了IO口为推挽输出,速度为50MHz,这里要强调的是,F0区别与F1的是,IO口配置这边,不能直接像F1一样推挽和输出是同时配置的,F0是分别配置的,还有就是右击IO口速度那里,我们可以看到:可以看出,如果我们使用GPIO_Speed_Level_3也可以代替GPIO_Speed_50MHz,可以更直观的看出IO口速度,具体怎样选择,还是得看个人选择.最后,在配置一下GPIO_Init函数就基本配置完成.那么,我们如何使得LED翻转呢,这里就可以用到GPIO_SetBits和GPIO_ResetBits两个函数,不过我还是喜欢用F1的位带操作.所以等一下,我们讲一下如何配置F0来实现位带操作.位带操作的配置位带操作,可以使我们输出高低电平时给1 or 0来实现,这样可以方便我们操控IO口,而且方便快捷,如果用操作函数的方式,翻转IO口就有点麻烦,所以这里我们设置下位带操作.我们可以在所在的工程中添加stm32f0xx_sys.h的头文件来存放,当我们需要使用位带操作时,直接调用就可以了.1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#ifndef __STM32F0xx_SYS_H#define __STM32F0xx_SYS_Htypedef struct&#123; unsigned short int b0 : 1; unsigned short int b1 : 1; unsigned short int b2 : 1; unsigned short int b3 : 1; unsigned short int b4 : 1; unsigned short int b5 : 1; unsigned short int b6 : 1; unsigned short int b7 : 1; unsigned short int b8 : 1; unsigned short int b9 : 1; unsigned short int b10 : 1; unsigned short int b11 : 1; unsigned short int b12 : 1; unsigned short int b13 : 1; unsigned short int b14 : 1; unsigned short int b15 : 1;&#125;REG16_TypeDef;//IO口地址映射#define GPIOA_ODR_Addr (GPIOA_BASE+0x14) //0x48000014#define GPIOB_ODR_Addr (GPIOB_BASE+0x14) //0x48000414#define GPIOC_ODR_Addr (GPIOC_BASE+0x14) //0x48000814#define GPIOD_ODR_Addr (GPIOD_BASE+0x14) //0x48000C14#define GPIOE_ODR_Addr (GPIOE_BASE+0x14) //0x48001014#define GPIOF_ODR_Addr (GPIOF_BASE+0x14) //0x48001414#define GPIOA_IDR_Addr (GPIOA_BASE+0x10) //0x48000010#define GPIOB_IDR_Addr (GPIOB_BASE+0x10) //0x48000410#define GPIOC_IDR_Addr (GPIOC_BASE+0x10) //0x48000810#define GPIOD_IDR_Addr (GPIOD_BASE+0x10) //0x48000C10#define GPIOE_IDR_Addr (GPIOE_BASE+0x10) //0x48001010#define GPIOF_IDR_Addr (GPIOF_BASE+0x10) //0x48001410 //IO口操作,只对单一的IO口!//确保n的值小于16!#define PAout ((volatile REG16_TypeDef *)GPIOA_ODR_Addr) //输出 #define PAin ((volatile REG16_TypeDef *)GPIOA_IDR_Addr) //输入 #define PBout ((volatile REG16_TypeDef *)GPIOB_ODR_Addr) //输出 #define PBin ((volatile REG16_TypeDef *)GPIOB_IDR_Addr) //输入 #define PCout ((volatile REG16_TypeDef *)GPIOC_ODR_Addr) //输出 #define PCin ((volatile REG16_TypeDef *)GPIOC_IDR_Addr) //输入 #define PDout ((volatile REG16_TypeDef *)GPIOD_ODR_Addr) //输出 #define PDin ((volatile REG16_TypeDef *)GPIOD_IDR_Addr) //输入 #define PEout ((volatile REG16_TypeDef *)GPIOE_ODR_Addr) //输出 #define PEin ((volatile REG16_TypeDef *)GPIOE_IDR_Addr) //输入#define PFout ((volatile REG16_TypeDef *)GPIOF_ODR_Addr) //输出 #define PFin ((volatile REG16_TypeDef *)GPIOF_IDR_Addr) //输入typedef unsigned char u8;typedef unsigned short int u16;typedef unsigned int u32; #endif这样位带操作就已经配置好了.结语因为时间的问题,我没有办法把整个工程一次性讲完,所以我会分篇讲解,今天就先说的这里,我只是个学生,如果在文章中有什么错误的地方,请不吝指教,谢谢！]]></content>
      <categories>
        <category>stm32</category>
      </categories>
      <tags>
        <tag>stm32</tag>
      </tags>
  </entry>
</search>
