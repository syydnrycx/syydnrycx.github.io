<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[一些实用的工具与软件]]></title>
    <url>%2F2018%2F12%2F20%2F%E4%B8%80%E4%BA%9B%E5%AE%9E%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7%E4%B8%8E%E8%BD%AF%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[前言最近访问我博客的人也越来越多了，想想似乎最近也没啥可以写的东西，所以就推荐一些我平时经常用的软件和工具吧，给大家提供参考~文本编辑Notepad++Notepad++ 顾名思义就是 windows 内置 Notepad 的增强版，它采用 C++ 编写，性能优秀，不仅小巧（完整安装包仅 4.78MB），功能众多，插件丰富，而且最关键的是“完全免费”！这一点比起 Editplus、UltraEdit、Sublime Text等其它文本处理软件来说，算是个大的卖点。支持语法高亮和颜色自定义可以添加插件更改格式、编码与符号可以给代码批量添加或取消注释….很多功能自行体会，看到身边好多人还在使用系统自带的记事本，功能小，使用十分不方便。使用Notepad++方便许多，博主自己也在用。下载地址Notepad++，进入官网，找到Download。UltraEditUltraEdit – 最强大的专业文本/十六进制编辑器！UltraEdit是世界上领先的，功能强大的，极具价值的文本编辑器、十六进制编辑器、HTML编辑器、PHP编辑器、Javascript编辑器、Perl 编辑器和程序编辑器。UltraEdit 是款全球功能一流的文本编辑软件，支持配置高亮语法和几乎所有编程语言的代码结构。内建英文单字检查，可同时编辑多个文件，编辑功能强大，具有代码提示、折叠、列操作等人性化功能。UltraEdit 体积大，功能强悍，很适合程序员使用，但我个人还是偏喜欢 Notepad++ 。这个体积稍微会大些，正版需要钱，所以我会提供个破解版，给需要的人，具体看后面结语~电子书阅读器calibrecalibre 是一个 “一站式” 的电子书解决方案，它可以全面满足你的电子书需求。calibre 是免费的，源代码开放，拥有跨平台的设计。它是一个完整的电子图书馆，包括图书馆管理，格式转换，新闻，将材料转换为电子书，以及电子书阅读器同步功能、整合进电子图书阅读器。界面与功能都十分强大，用来做看书最好不过了~calibre下载工具Readiris Corporate 17Readiris Corporate 是一款专业的文字OCR识别工具软件，其强大的识别能力和丰富的字库可使识别率达到98%以上。目前最新的Readiris Corporate 适用于Vista/Windows 7/Windows 10等系统平台，加入亚洲语言包后，简繁体中文、英文、德语、日韩……统统拿下！识别出来的图文混排照样能够遵照原来的版式不变。图文报纸的识别准确率不低于96%，日常公文的识别准确率不低于99%！还支持扫描仪的OCR识别，支持PDF文字识别、数码相机拍摄识别。拿来把扫描版的电子书，转成可以复制文字的电子书再好不过了，还支持其他格式的扫描，输出不同的格式。具体怎样下载破解，看后面结语。冰点文库素材下载器冰点文库下载器，下载文档利刃当之首选！免积分无需登录即可免费下载百度和豆丁文库。它支持百度、豆丁、丁香、畅享、MBALib、IT168、HP009、MAX、Book118、道客巴巴、金字塔医学、大桔灯等文库文档。支持多任务同时下载及断点续传，下载的文档与原始文档质量等同，最终生成高清晰PDF格式文档。这里缺点就在于只能生成高清晰的PDF格式文档，所以需要结合上面的OCR识别工具，配合起来用。结语上面那些没有链接需要破解的软件，我都放在网盘上了，网盘链接可以扫描下面微信公众号，回复“OCR”获取~。]]></content>
      <categories>
        <category>软件</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>软件</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使用apktool反编译apk]]></title>
    <url>%2F2018%2F12%2F14%2F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8apktool%E5%8F%8D%E7%BC%96%E8%AF%91apk%2F</url>
    <content type="text"><![CDATA[前言因为一直使用别人的破解的 apk 相关软件，所以十分好奇是怎么做到的，查阅了一下然后做了个总结。安装apktool首先，我们去Apktool官网，按照步骤进行安装，1. 保存 脚本;2. 下载 apktool ，并且重命名为 apktool.jar ;3. 移动 apktool.bat 和 apktool.jar 到 C:\Windows ;最后在命令行输入 apktool 如下图，则成功，dex2jar与jd-gui首先，我们可以把你要反编译的apk(后缀是.apk)的，更改下格式为.zip，然后我们打开并解压它，因为我们需要的源代码就在里面。解压出来的文件中，我们需要对 classes.dex 进行操作。在这之前，我们需要下载dex2jar 与 jd-gui ，进入dex2jar官网，里面下载。我标红的这两个都需要，下载完解压出来，这里两个我都解压在D盘，接下来，我们把刚才说的 classes.dex 放入 D:\dex2jar-2.0里面，然后命令行执行如下：123cd D:\dex2jar-2.0cd D:d2j-dex2jar.bat classes.dex执行完，会出现 classes-dex2jar，这个就是我们需要的.jar文件。接下来要用到我们的另一个工具 jd-gui.exe，我们执行它，并且这就是我们需要的源代码。apktool使用可以查看源码之后，再修改相关代码，就需要我们刚才下载的 apktool 了，我的.apk放在桌面上通过cmd命令执行 apktool d app-debug.apk,填写你apk的名字，然后反编译。得到:最后,smali是源码编译后的地方，res是apk的资源文件，我们需要修改的就在这些里面，但是我们还需要理解smali语法才能修改，这里不再多说。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发-Apache服务器下载和安装]]></title>
    <url>%2F2018%2F11%2F27%2FAndroid%E5%BC%80%E5%8F%91-Apache%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8B%E8%BD%BD%E5%92%8C%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[前言在学习郭霖的《第一行代码》中有提到需要搭建Web服务器，书中用的也是推荐大家下载Apache，所以这一篇文章就来说如何下载与安装。下载Apache首先，我们进入Apache官网，在左侧找到Download。然后我们找到Files for Microsoft Windows(博主是win10系统)，下方找到Downloading Apache for Windows，找到ApacheHaus，进去后找到你需要的版本与匹配的位数，点击右侧的小图片下载，这样就把我们需要的Apache下载下来了。安装Apache我们把下载好的压缩包解压放到C盘或者其他盘(这里我解压在了D盘)，我们找到“D:\Apache24\conf“下的httpd.conf文件以文本的形式打开，找到Define SRVROOT &quot;xxx&quot;,将xxx修改为你存放解压下来Apache的位置，这里我是放在&quot;D:\Apache24&quot;，完成后保存，然后我们&quot;win+R&quot;输入cmd，通过cd命令进入Apache的bin文件夹，然后输入&quot;httpd.exe&quot; -k install -n apache，(双引号不能忽略)如果提示权限不足，右键开始菜单，打开命令提示符(管理员)，以管理员来安装，安装完成后，回到bin文件夹，打开ApacheMonitor.exe，在你的任务栏可以找到它的小图标，然后我们双击它可以打开窗口界面，然后我们点击start按钮开启服务，然后我们打开浏览器，访问&quot;http://localhost&quot;，看到如下界面，就成功了。]]></content>
      <categories>
        <category>Android</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发-注册登录与手机验证登录]]></title>
    <url>%2F2018%2F11%2F25%2FAndroid%E5%BC%80%E5%8F%91-%E6%B3%A8%E5%86%8C%E7%99%BB%E5%BD%95%E4%B8%8E%E6%89%8B%E6%9C%BA%E9%AA%8C%E8%AF%81%E7%99%BB%E5%BD%95%2F</url>
    <content type="text"><![CDATA[效果图前言这篇主要讲如何通过数据库添加用户注册账户并且验证账户并且登录，还可以通过手机接收验证码登录。准备登陆 MOB官网 注册账户，注册好后登录，进入后台，并且我们添加一个应用。应用名称根据个人喜好。这里我随便命名了个11应用，这里我们进入概况。这里我们记录一下应用Appkey与App Secret，后面我们会用到，并且我们开启短信验证功能。弄完后，我们回到 MOB官网 进入下载中心。然后我们下载短信验证功能的包。我是通过离线下载的SDK包，然后解压出我们需要的东西[路径(sms/SMSSDK/SMSSDK/libs)]然后解压这4个jar包。到这里，要准备的东西基本全了，有漏的后面再补充。建立工程这里我就不多说了，新建一个标准的工程，然后开始添加我们需要的东西。并且将我们解压的4个jar包加进工程里。开始准备布局我们先把需要的布局准备好，actuvuty_main.xml我只放了个登录成功的显示。12345678910111213141516&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="登陆成功" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintRight_toRightOf="parent" app:layout_constraintTop_toTopOf="parent" /&gt;&lt;/android.support.constraint.ConstraintLayout&gt;登录界面布局文件logic_layout.xml十分简单，放置了几个Button与编辑框，编辑框下拉我用的是ListPopupWindow来显示。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="fill_parent" android:layout_height="fill_parent" android:background="@drawable/background" android:orientation="vertical"&gt; &lt;LinearLayout android:id="@+id/layout" android:layout_width="fill_parent" android:layout_height="50dp" android:layout_marginTop="50dp" android:layout_gravity="center_vertical" android:orientation="horizontal" &gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginLeft="30dp" android:text="账户：" /&gt; &lt;com.example.syydnrycx.sqlitelogin.Class.ClearEditText android:id="@+id/user_name" android:layout_width="220dp" android:layout_height="40dp" android:drawableLeft="@drawable/user_name" android:drawablePadding="6dp" android:hint="name_tip" android:singleLine="true" android:background="@drawable/myedit_style" &gt; &lt;requestFocus /&gt; &lt;/com.example.syydnrycx.sqlitelogin.Class.ClearEditText&gt; &lt;ImageButton android:id="@+id/user_btn_img" android:layout_width="wrap_content" android:layout_height="wrap_content" android:background="@drawable/lg_down" android:paddingRight="2dip" android:scaleType="fitXY" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width="fill_parent" android:layout_height="50dp" android:layout_gravity="center_vertical" android:orientation="horizontal" &gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginLeft="30dp" android:text="密码：" /&gt; &lt;EditText android:id="@+id/user_pass" android:layout_width="220dp" android:layout_height="40dp" android:background="@drawable/myedit_style" android:layout_marginLeft="5dp" android:hint="密码" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width="fill_parent" android:layout_height="50dp" android:layout_gravity="center_vertical" android:orientation="horizontal" &gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginLeft="30dp" android:text="手机：" /&gt; &lt;EditText android:id="@+id/ed_phone" android:layout_width="220dp" android:layout_height="40dp" android:layout_marginLeft="5dp" android:background="@drawable/myedit_style" android:hint="手机号" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width="fill_parent" android:layout_height="wrap_content" android:layout_gravity="center_vertical" android:orientation="horizontal" &gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginLeft="30dp" android:text="验证码：" /&gt; &lt;EditText android:id="@+id/ed_code" android:layout_width="100dp" android:layout_height="40dp" android:background="@drawable/myedit_style" android:layout_marginLeft="5dp" android:hint="验证码" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width="fill_parent" android:layout_height="wrap_content" android:layout_marginTop="10dp" android:orientation="horizontal" &gt; &lt;Button android:id="@+id/bt_login" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginLeft="80dp" android:background="@drawable/mybutton_style" android:text="登录" /&gt; &lt;Button android:id="@+id/bt_register" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginLeft="20dp" android:background="@drawable/mybutton_style" android:text="注册" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width="fill_parent" android:layout_height="wrap_content" android:layout_marginTop="10dp" android:orientation="horizontal" &gt; &lt;Button android:id="@+id/bt_getphonecore" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginLeft="60dp" android:background="@drawable/mybutton_style" android:text="获取验证码" /&gt; &lt;Button android:id="@+id/bt_corelogin" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginLeft="20dp" android:background="@drawable/mybutton_style" android:text="验证码登录" /&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt;注册界面布局文件register_layout.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="fill_parent" android:layout_height="fill_parent" android:orientation="vertical" &gt; &lt;LinearLayout android:layout_width="fill_parent" android:layout_height="50dp" android:layout_gravity="center_vertical" android:layout_marginTop="20dp" android:orientation="horizontal" &gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginLeft="30dp" android:text="帐号：" /&gt; &lt;EditText android:id="@+id/usernameRegister" android:layout_width="220dp" android:layout_height="40dp" android:background="@drawable/myedit_style" android:layout_marginLeft="5dp" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width="fill_parent" android:layout_height="50dp" android:layout_gravity="center_vertical" android:orientation="horizontal" &gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginLeft="30dp" android:text="密码：" /&gt; &lt;EditText android:id="@+id/passwordRegister" android:layout_width="220dp" android:layout_height="40dp" android:background="@drawable/myedit_style" android:layout_marginLeft="5dp" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width="fill_parent" android:layout_height="wrap_content" android:layout_marginTop="10dp" android:orientation="horizontal" &gt; &lt;Button android:id="@+id/Register" android:layout_width="match_parent" android:layout_height="wrap_content" android:background="@drawable/mybutton_style" android:text="注册" /&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt;javajava文件我会挑些重要的解释，剩余我觉得无关紧要的，大家可以在我的Github上下载下来看。数据库建立 DatabaseHelper.java1234567891011121314151617public class DatabaseHelper extends SQLiteOpenHelper &#123; static String name="user.db"; static int dbVersion=1; public DatabaseHelper(Context context) &#123; super(context, name, null, dbVersion); &#125; //只在创建的时候用一次 public void onCreate(SQLiteDatabase db) &#123; String sql="create table user(id integer primary key autoincrement,username varchar(80),password varchar(80))"; db.execSQL(sql); &#125; //升级 public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123; &#125;&#125;登录、注册、获取ListPopupWindow显示账户 UserService.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class UserService &#123; private ArrayList&lt;String&gt; usernameList = new ArrayList&lt;&gt;(); private DatabaseHelper dbHelper; private String s = null; public UserService(Context context)&#123; dbHelper=new DatabaseHelper(context); &#125; //登录用 public boolean login(String username,String password)&#123; SQLiteDatabase sdb=dbHelper.getReadableDatabase(); String sql="select * from user where username=? and password=?"; Cursor cursor=sdb.rawQuery(sql, new String[]&#123;username,password&#125;); if(cursor.moveToFirst()==true)&#123; cursor.close(); return true; &#125; return false; &#125; //注册用 public boolean register(User user)&#123; //用getReadable和getWriteable都可以创建或者打开一个数据库并返回一个可对数据库进行读写操作的对象，当数据库满R可以只读，W会报错 SQLiteDatabase sdb=dbHelper.getReadableDatabase(); String sql="insert into user(username,password) values(?,?)"; Object obj[]=&#123;user.getUsername(),user.getPassword()&#125;; sdb.execSQL(sql, obj); return true; &#125; public ArrayList&lt;String&gt; getAll() &#123; SQLiteDatabase sdb=dbHelper.getReadableDatabase(); //查询获得游标 Cursor cursor = sdb.query ("user",null,null,null,null,null,null); //判断游标是否为空 if(cursor.moveToFirst()) &#123; //遍历游标 do&#123; //获得用户名 usernameList.add(cursor.getString(1)); &#125;while(cursor.moveToNext()); cursor.close(); &#125; return usernameList; &#125;&#125;主要的登录逻辑与手机验证获取123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245public class LoginActivity extends Activity implements View.OnClickListener&#123; private ArrayList&lt;String&gt; usernamelList; private Button bt_login,bt_register,bt_getphonecore,bt_corelogin; private ImageButton image_btn; private EditText edit_username; private EditText edit_password; private EditText edit_phone; private EditText edit_cord; private UserService uService = null; private ListPopupWindow listPopupWindow; private String phone_number; private String cord_number; EventHandler eventHandler; private boolean coreflag=true; private Context context; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.logic_layout); initViews(); sms_verification(); &#125; private void initViews() &#123; bt_login=(Button) findViewById(R.id.bt_login); bt_register=(Button) findViewById(R.id.bt_register); bt_getphonecore=(Button) findViewById(R.id.bt_getphonecore); bt_corelogin=(Button) findViewById(R.id.bt_corelogin); image_btn=(ImageButton)findViewById(R.id.user_btn_img); edit_username=(EditText) findViewById(R.id.user_name); edit_password=(EditText) findViewById(R.id.user_pass); edit_phone=(EditText)findViewById(R.id.ed_phone); //你的手机号 edit_cord=(EditText)findViewById(R.id.ed_code);//你的验证码 bt_login.setOnClickListener(this); bt_register.setOnClickListener(this); bt_getphonecore.setOnClickListener(this); bt_corelogin.setOnClickListener(this); image_btn.setOnClickListener(this); uService = new UserService(LoginActivity.this); usernamelList = uService.getAll(); &#125; protected void onDestroy() &#123;//销毁 super.onDestroy(); SMSSDK.unregisterEventHandler(eventHandler); &#125; protected void onResume() &#123; super.onResume(); usernamelList.clear(); //从注册返回时清除usernamelList usernamelList = uService.getAll(); //更新注册的内容 &#125; private void showListPopulWindow() &#123; listPopupWindow = new ListPopupWindow(this); listPopupWindow.setAdapter(new ArrayAdapter&lt;String&gt;(this,R.layout.list_item, usernamelList));//用android内置布局，或设计自己的样式 listPopupWindow.setAnchorView(edit_username);//以哪个控件为基准，在该处以mEditText为基准 listPopupWindow.setModal(true); listPopupWindow.setOnItemClickListener(new AdapterView.OnItemClickListener() &#123;//设置项点击监听 @Override public void onItemClick(AdapterView&lt;?&gt; adapterView, View view, int i, long l) &#123; edit_username.setText(usernamelList.get(i));//把选择的选项内容展示在EditText上 listPopupWindow.dismiss();//如果已经选择了，隐藏起来 &#125; &#125;); listPopupWindow.show();//把ListPopWindow展示出来 &#125; //按钮点击事件 @Override public void onClick(View v) &#123;/* String phone_number=edit_phone.getText().toString();//1 String cord_number=bt_getcord.getText().toString().trim();//1*/ switch (v.getId())&#123; case R.id.bt_login://登录监听 String name=edit_username.getText().toString(); String pass=edit_password.getText().toString(); boolean flag=uService.login(name, pass); if(flag)&#123; Log.i("TAG","登录成功"); Intent intent=new Intent(LoginActivity.this,MainActivity.class); startActivity(intent); Toast.makeText(LoginActivity.this, "登录成功", Toast.LENGTH_LONG).show(); &#125;else&#123; Log.i("TAG","登录失败"); Toast.makeText(LoginActivity.this, "登录失败", Toast.LENGTH_LONG).show(); &#125; break; case R.id.bt_register://注册监听 Intent intent=new Intent(LoginActivity.this,RegisterActivity.class); startActivity(intent); break; case R.id.bt_getphonecore://获取验证码的ID if(judPhone())&#123;//去掉左右空格获取字符串，是正确的手机号 SMSSDK.getVerificationCode("86",phone_number);//获取你的手机号的验证码 edit_cord.requestFocus();//判断是否获得焦点 &#125; break; // 获取后要提交你的验证码以判断是否正确，并登陆成功 case R.id.bt_corelogin://登陆页面的ID if(judCord()) &#123;//判断验证码 SMSSDK.submitVerificationCode("86", phone_number, cord_number);//提交手机号和验证码 startActivity(new Intent(this,MainActivity.class)); &#125; coreflag=false; break; case R.id.user_btn_img://编辑框下拉监听 showListPopulWindow(); //调用显示PopuWindow 函数 break; &#125; &#125; private boolean judPhone() &#123;//判断手机号是否正确 //不正确的情况 if(TextUtils.isEmpty(edit_phone.getText().toString().trim()))//对于字符串处理Android为我们提供了一个简单实用的TextUtils类，如果处理比较简单的内容不用去思考正则表达式不妨试试这个在android.text.TextUtils的类，主要的功能如下: //是否为空字符 boolean android.text.TextUtils.isEmpty(CharSequence str) &#123; Toast.makeText(LoginActivity.this,"请输入您的电话号码",Toast.LENGTH_LONG).show(); edit_phone.requestFocus();//设置是否获得焦点。若有requestFocus()被调用时，后者优先处理。注意在表单中想设置某一个如EditText获取焦点，光设置这个是不行的，需要将这个EditText前面的focusable都设置为false才行。 return false; &#125; else if(edit_phone.getText().toString().trim().length()!=11)&#123; Toast.makeText(LoginActivity.this,"您的电话号码位数不正确",Toast.LENGTH_LONG).show(); edit_phone.requestFocus(); return false; &#125; //正确的情况 else&#123; phone_number=edit_phone.getText().toString().trim(); String num="[1][3578]\\d&#123;9&#125;"; if(phone_number.matches(num)) &#123; return true; &#125; else&#123; Toast.makeText(LoginActivity.this,"请输入正确的手机号码",Toast.LENGTH_LONG).show(); return false; &#125; &#125; &#125; private boolean judCord() &#123;//判断验证码是否正确 judPhone();//先执行验证手机号码正确与否 if(TextUtils.isEmpty(edit_cord.getText().toString().trim())) &#123;//验证码 Toast.makeText(LoginActivity.this, "请输入您的验证码", Toast.LENGTH_LONG).show(); edit_cord.requestFocus();//聚集焦点 return false; &#125; else if(edit_cord.getText().toString().trim().length()!=4)&#123; Toast.makeText(LoginActivity.this,"您的验证码位数不正确",Toast.LENGTH_LONG).show(); edit_cord.requestFocus(); return false; &#125; else&#123; cord_number=edit_cord.getText().toString().trim(); return true; &#125; &#125; public void sms_verification()&#123; //MobSDK.init(context, "28bc12fa236e4","44cb357655f252a8a75eac378b8283ad"); eventHandler = new EventHandler() &#123; public void afterEvent(int event, int result, Object data) &#123; Message msg=new Message();//创建了一个对象 msg.arg1=event; msg.arg2=result; msg.obj=data; handler.sendMessage(msg); &#125; &#125;; SMSSDK.registerEventHandler(eventHandler);//注册短信回调（记得销毁，避免泄露内存）*/ &#125; /** * 使用Handler来分发Message对象到主线程中，处理事件 */ Handler handler=new Handler()&#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); int event=msg.arg1; int result=msg.arg2; Object data=msg.obj; if (event == SMSSDK.EVENT_GET_VERIFICATION_CODE) &#123;//获取验证码成功 if(result == SMSSDK.RESULT_COMPLETE) &#123; //回调完成 boolean smart = (Boolean)data; if(smart) &#123; Toast.makeText(getApplicationContext(),"该手机号已经注册过，请重新输入",Toast.LENGTH_LONG).show(); edit_phone.requestFocus();//焦点 return; &#125; &#125; &#125; //回调完成 if (result==SMSSDK.RESULT_COMPLETE)&#123; if (event == SMSSDK.EVENT_SUBMIT_VERIFICATION_CODE) &#123;//提交验证码成功 Toast.makeText(getApplicationContext(), "验证码输入正确",Toast.LENGTH_LONG).show(); &#125; &#125;else &#123;//其他出错情况 if(coreflag)&#123; bt_getphonecore.setVisibility(View.VISIBLE); Toast.makeText(getApplicationContext(),"验证码获取失败请重新获取", Toast.LENGTH_LONG).show(); edit_phone.requestFocus(); &#125; else&#123; Toast.makeText(getApplicationContext(),"验证码输入错误", Toast.LENGTH_LONG).show(); &#125; &#125; &#125; &#125;;&#125;添加 Appkey 与 App Secret在AndroidManifest.xml中增加12&lt;meta-data android:name="Mob-AppKey" android:value="xxx"/&gt;&lt;meta-data android:name="Mob-AppSecret" android:value="xxx"/&gt;还要把需要的权限增加进去12345678910&lt;uses-permission android:name="android.permission.READ_CONTACTS" /&gt;&lt;uses-permission android:name="android.permission.READ_PHONE_STATE" /&gt;&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt;&lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" /&gt;&lt;uses-permission android:name="android.permission.ACCESS_WIFI_STATE" /&gt;&lt;uses-permission android:name="android.permission.INTERNET" /&gt;&lt;uses-permission android:name="android.permission.RECEIVE_SMS" /&gt;&lt;uses-permission android:name="android.permission.READ_SMS" /&gt;&lt;uses-permission android:name="android.permission.GET_TASKS" /&gt;&lt;uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" /&gt;完整的1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.example.syydnrycx.sqlitelogin"&gt; &lt;uses-permission android:name="android.permission.READ_CONTACTS" /&gt; &lt;uses-permission android:name="android.permission.READ_PHONE_STATE" /&gt; &lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt; &lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" /&gt; &lt;uses-permission android:name="android.permission.ACCESS_WIFI_STATE" /&gt; &lt;uses-permission android:name="android.permission.INTERNET" /&gt; &lt;uses-permission android:name="android.permission.RECEIVE_SMS" /&gt; &lt;uses-permission android:name="android.permission.READ_SMS" /&gt; &lt;uses-permission android:name="android.permission.GET_TASKS" /&gt; &lt;uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" /&gt; &lt;application android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:roundIcon="@mipmap/ic_launcher_round" android:supportsRtl="true" android:theme="@style/AppTheme"&gt; &lt;activity android:name=".Activity.LoginActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=".Activity.RegisterActivity"&gt; &lt;/activity&gt; &lt;activity android:name=".Activity.MainActivity"&gt; &lt;/activity&gt; &lt;activity android:name="com.mob.tools.MobUIShell" android:theme="@android:style/Theme.Translucent.NoTitleBar" android:configChanges="keyboardHidden|orientation|screenSize" android:windowSoftInputMode="stateHidden|adjustResize"/&gt; &lt;meta-data android:name="Mob-AppKey" android:value="xxx"/&gt; &lt;meta-data android:name="Mob-AppSecret" android:value="xxx"/&gt; &lt;/application&gt;&lt;/manifest&gt;结主要的注释在代码中都有体现，还有一些代码没有贴出来可以在我的Github上下载下来看。]]></content>
      <categories>
        <category>Android</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio adb shell 无法设置为超级用户的解决方法]]></title>
    <url>%2F2018%2F09%2F13%2FAndroid-Studio-adb-shell-%E6%97%A0%E6%B3%95%E8%AE%BE%E7%BD%AE%E4%B8%BA%E8%B6%85%E7%BA%A7%E7%94%A8%E6%88%B7%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言在学习郭霖著的《第一行代码》时，其中在 SQLite 数据库存储时要运用 adb shell 访问数据库文件时，无法设置权限为超级管理员权限，为此停滞了好久，后来上网查询后知道 Android7.0 虚拟机没有root权限。所以我们在 adb shell 执行命令 su 回应 not found 。解决既然 Android 7.0 虚拟机无法设置权限，那我们退而求其次使用 Android 6.0的虚拟机 就可以设置超级管理员权限。所以我们可以进入 Android Virtual Device Manager 新建一个虚拟机，点击 Create Virtual Device..，选择一个机型后我们点击 next，我们下载一个7.0以下的版本，这里我选择了一个 Android 6.0版本 的虚拟机，设置好后，我把我的 app 装在新的虚拟机上，并且在 cmd 上输入 adb shell，这时候我们可以看到从之前的 $：普通管理员，自动的变为 #：超级管理员。假如没有自动设置为 #：超级管理员的话我们可以通过 su 来设置。到此，设置权限的问题已经解决。]]></content>
      <categories>
        <category>Android</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Visual Studio Professional 2015安装]]></title>
    <url>%2F2018%2F09%2F04%2FVisual%20Studio%20Professional%202015%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Visual Studio Professional 2015安装下载首先，从我的网盘 密码: iycx，下载镜像文件。安装将下载好的.iso镜像文件解压:后双击解压的.exe文件，开始初始化安装:设置要安装的文件路径，这里我选择了D盘:接下来选择我们需要的功能，根据自己的需求选择:【Visual C++】是可选的，如果你希望用C++开发各种类型的应用程序，需要勾选它。【Visual F#】与【python工具】是可选的，开发Android应用程序时需要勾选。【windows和web开发】如果你希望在VS中使用与办公软件交互的功能时需要勾选，不做阐述。【Windows 8.1和Windows Phone 8.0/8.1工具】不推荐勾选，使用很少【常用工具和软件开发工具包】根据需要勾选确认自己需要的功能后点击下一步，再点击安装:安装时间漫长，可以冲杯茶休息一下。安装完毕后，选择开发环境，这里我选择 C#:等待环境初始化:完成后，界面弹出:破解打开菜单栏的帮助，点击注册产品:在右边栏显示试用期30天，填写秘钥: HMGNV-WCYXV-X7G9W-YCX63-B98R2显示如下，则破解OK。]]></content>
      <categories>
        <category>软件安装</category>
      </categories>
      <tags>
        <tag>软件安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PADS9.5安装及破解]]></title>
    <url>%2F2018%2F04%2F21%2FPADS9-5%E5%AE%89%E8%A3%85%E5%8F%8A%E7%A0%B4%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[前言好久没更新了,最近好忙好忙的,闲来无事,这一篇就说说怎样安装PADS9.5吧.PADS9.5安装下载安装之前,可以点击 密码: iycx,安装相应软件及破解工具.安装打开下载好的目录,解压里面的’PADS_9-5.part1’和’MentorCrackMaserV2_0_1’,这里我已经解压好了,解压完毕后,打开PADS_9-5文件夹,找到’PADS9.5_mib’,右键属性,在兼容性中勾选以管理员身份运行此程序,然后我们双击运行它,在安装窗口中我们点击’next’,然后点击’skip’,再点击’Agree,接下来,我们先配置下需要安装的东西,这里点击’Modify’,选择’Product Selection’,这里把全部勾选,除了最后的’Server Services’不勾选,然后,我们选择’Target Path’,选择要安装的目录,这里我默认安装在C盘,在最后的一个选项’PADS Projects Path’中选择PADS工程路径,这里我也默认,选择好了安装路径后,我们点击’Done’,确认无误后,我们点击’Install’开始安装,等到进度条走完后,我们选择’at a later time’,先破解后,我们在打开软件.这个时候,桌面就有了安装好的软件.破解我们打开解压’MentorCrackMaserV2_0_1’的目录,找到’MentorCrackMaster’,然后点击浏览,找到我们安装PADS的根目录,这里我刚才安装在C盘,所以C盘里直接选中该路径就可以了,如果你安装在其他盘,一样找到’MentorGraphics’这个目录,然后点击破戒,会弹出窗口,等待即可,破解成功会显示成功界面.修改软件语言我们打开Layout或者Logic其中一个软件,这里我的是中文界面,假设我想要英文界面,这里我们打开工具,找到’自定义’,在选项中,找到界面语言,修改为’English’,更改后会提示重启软件,我们关闭软件重新打开就好了,这个时候软件语言就变为英文的了,结语到这里,基本安装及破解都没有问题了.]]></content>
      <categories>
        <category>软件安装</category>
      </categories>
      <tags>
        <tag>软件安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MDK5环境安装与建立工程模板]]></title>
    <url>%2F2018%2F04%2F15%2FMDK5%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E5%BB%BA%E7%AB%8B%E5%B7%A5%E7%A8%8B%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[前言这一篇讲怎么安装MDK5环境与stm32f103zet6工程模板的建立,包含了软件安装,st-link驱动安装与工程模板建立.文章比较长,请细心看~.MDK5环境安装下载装软件之前,请先下载MDK5.14及相关的破解等软件.软件及破解软件 密码: iycx固件库安装 密码: iycx二个都要安装,缺一不可MDK5.14安装下载完软件后,就开始我们的安装,首先打开我们的软件目录,里面有MDK5和ST LINK驱动及教程.我们先打开MDK5文件夹,找到mdk514.exe,并双击打开它,弹出安装窗口,我们点击next,勾选I agree to all the tems of the preceding License Agreement 并点击next,选择安装的目录,可以在D盘等其他盘,这里我不改动,直接安装在C盘,安装在其他盘时不要改动安装的文件夹,直接修改盘符就行.比如我安装在D盘:请修改C:\Keil_v5 为D:\Keil_v5, 修改C:\Keil_v5\ARM\PACK为D:\Keil_v5\ARM\PACK避免不必要的麻烦.选择好安装目录后,我们点击next,在弹出来的,填写信息,这里随便填就可以了,填完点击next等待安装完成,进度条走完会弹出是否安装设备软件,这里点安装,安装完成后,取消勾选Show Release Notes并点击Finish在弹出来的窗口,关掉就可以了.到这里软件就装好了.MDK5.14破解在桌面Keil uVision5的快键方式中,右键属性,找到兼容性,勾选以管理员身份运行此程序,然后点击确定.然后我们运行软件,在左上角File中找到License Management..,打开它.先晾在一边冷静一下,找到我们MDK5安装包的位置,打开keygen文件夹,并运行keygen,我们复制keil5中的CID到keygan中的CID窗口里, 并选择ARM然后点击Gemerate,把生成的一段码复制到Keil5的LIC位置,点击Add LIC,出现了Expires:Oct 2020,恭喜你,程序已经破解OK了,MDKF1支持包安装还是打开MDK安装包的目录,找到Keil.STM32F1xx_DFP.1.0.5.pack双击它,在弹出来的窗口点击next,安装完成后,我们点Finsh,ST-LINK驱动安装还是在刚才下载的目录中,我们找到ST LINK驱动及教程\ST-LINK驱动\ST-LINK官方驱动中的dpinst_x86与dpinst_amd64,至于装哪个,看你的电脑是几位的来装就可以了,双击打开它,并点击next,安装设备软件,安装完后点击完成.这样ST-LINK的驱动也装好了.STM32f103ZET6工程模板建立打开下载的另一个F1固件库文件夹,先晾在一边,我们在桌面新建一个文件夹来存放工程,这里我命名Project_Demo,打开keil5,在上面找到Project-New uVision Project,点击它.把它命个名保存到刚才新建的文件夹中,这里我命名为Project,你可以命名一个相关你项目的名字也是可以的,保存后,在弹出的窗口中我们找到我们的芯片STM32F103ZE点击OK,并关掉接下来弹出的窗口,这个时候我们可以看一下我们的工程目录中多了几个文件,这里的Listings和Objects可以删除,后面我们把生成的文件保存到另外一个文件夹了,我们在工程模板中新建几个文件夹:USER:存放工程文件例如main、中断等STARUP:存放我们的启动文件和核心文件ST_LIB:存放官方库函数Output:存放我们的生成文件Prj:存放项目文件接下来,我们在ST_LIB中添加库函数文件,打开固件库目录,\Libraries\STM32F10x_StdPeriph_Drive\复制inc与src文件夹到ST_LIB中,添加我们的启动文件和核心文件,\Libraries\CMSIS\CM3\CoreSupport中的core_cm3.c和core_cm3.h到STARUP中,再找到\Libraries\CMSIS\CM3\DeviceSupport\ST\startup\arm中的startup_stm32f10x_hd.s到STARUP中,在定位到\Libraries\CMSIS\CM3\DeviceSupport\ST中复制stm32f10x.h、system_stm32f10x.c、system_stm32f10x.h到USER文件中,定位到\STM32F10x_StdPeriph_Lib_V3.5.0\Project\STM32F10x_StdPeriph_Template中,复制main.c、stm32f10x_conf.h、stm32f10x_it.c、stm32f10x_it.h到USER中,回到keil5,右键Target1,点击Manage Project Items..,在Groups栏中删除Source Group 1,添加USER、STAUP、ST_LIB、Prj,点击USER,Add Files..添加main.c、stm32f10x_it.c、system_stm32f10x.c,点击STAUP,Add Files..选择显示所以文件类型,并把core_cm3.c与startup_stm32f10x_hd.s添加进来,点击ST_LIB,Add Files..添加ST_LIB中src的所有文件,Ctrl+A选中所有,添加到ST_LIB,只是src文件夹里的,不包括inc里面的文件.Prj先不添加,因为现在没有需要的项目文件需要添加,我们点击一个类似锤子的东西”魔术棒”,找到Output,Select Folder for Objects选中要输出编译生成文件的目录Output,最好把Create HEX file也勾上,因为如果你用串口来烧写程序,你就需要HEX文件了,点击OK,我们在打开一起魔术棒,找到C/C++,在Define栏中添加STM32F10X_HD,USE_STDPERIPH_DRIVER,最好复制过去,自己打错了就会引起不必要的麻烦,然后我们添加头文件,点击删除图标左边的新建,添加USER这个目录,在依次添加ST_LIB中的inc文件夹与STARUP文件夹,如图所示:确认无误后确定,然后我们删除main.c里面的所有代码,添加:1234567#include "stm32f10x.h"int main(void)&#123;&#125;然后我们点击左上方的编译,如果没有报错编译后的输出窗口应该是这样的:到了这里,工程模板就建立好啦,如果你写了你的项目文件,比如led.c与led.h你就可以把它放入Prj目录中,并在keil的Prj中添加.c文件,在魔术棒中的C/C++中添加led.h所在的目录.结语MDK环境与安装与模板的建立就完了,如果过程中有什么问题,可以在下方留言,只要细心按步骤来,是不会有问题的!~~]]></content>
      <categories>
        <category>stm32</category>
        <category>软件安装</category>
      </categories>
      <tags>
        <tag>软件安装</tag>
        <tag>stm32</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[stm8学习笔记-串口]]></title>
    <url>%2F2018%2F04%2F15%2Fstm8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%B2%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[前言在单片机中,串口是我们很多项目中离不开的功能,它可以帮助我们调试程序,打印信息,用两根线就可以实现收与发,所以这一篇,我们介绍一下串口的配置.串口配置配置串口前,要先说的是我配置的是串口3,并且用的是寄存器的方式配置的,所以在配置中有什么不理解的最好查手册首先,我们在.h中定义初始化函数uart3_init(u32 bound), bound是要初始化的波特率.然后我们看一下寄存器的配置:根据上面框起来的来配置寄存器,最后在通过UART-&gt;BBR2与UART-&gt;BBR1来写入波特率,后开启UART就可以了具体的我们看下面程序.程序123456789101112131415161718192021uart3.h#ifndef __UART3_H#define __UART3_H#include "stm8s.h"#include &lt;stdio.h&gt;#define HSIClockFreq 16000000#define UART3_FLAG_TXE (uint8_t)0x80 //发送数据寄存器空标志 #define UART3_FLAG_RXNE (uint8_t)0x20 //读取数据寄存器非空标志#define U3RxBufferSize 64extern u8 USART3_RX_BUF[U3RxBufferSize]; extern u8 USART3_TX_BUF[U3RxBufferSize];extern u8 USART3_RX_STA; void uart3_init(u32 bound);void UART3_SendByte(u8 data);void UART3_SendString(u8* str);void u3_printf(char* fmt,...);#endif12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879uart3.c#include "uart3.h"#include "stdarg.h" #include "stdio.h" #include "string.h" u8 USART3_TX_BUF[U3RxBufferSize];u8 USART3_RX_BUF[U3RxBufferSize]; //接收缓冲,最大USART_REC_LEN个字节.//接收状态//bit15， 接收完成标志//bit14， 接收到0x0d//bit13~0， 接收到的有效字节数目u8 USART3_RX_STA=0; //接收状态标记 void uart3_init(u32 bound)&#123; //1位起始位 8位数据位 结束位由CR3设置 不使用奇偶校验 不使能奇偶校验中断 UART3-&gt;CR1 &amp;= 0xE0; //禁止发送中断和空闲中断， 使能发送和接收 使能接收中断 UART3-&gt;CR2 = (0&lt;&lt;7)|(0&lt;&lt;6)|(1&lt;&lt;5)|(0&lt;&lt;4)|(1&lt;&lt;3)|(1&lt;&lt;2); //禁止LIN模式， 设置1位停止位 不使能CLK时钟 UART3-&gt;CR3 &amp;= 0x07; /*设置波特率*/ bound =HSIClockFreq/bound; /*求出分频因子*/ UART3-&gt;BRR2 = bound &amp; 0x0f; UART3-&gt;BRR2 |= ((bound &amp; 0xf000) &gt;&gt; 8); UART3-&gt;BRR1 = ((bound &amp; 0x0ff0) &gt;&gt; 4); /*先给BRR2赋值 最后再设置BRR1*/ UART3-&gt;CR1 |= (0&lt;&lt;5); /*使能UART*/&#125;/******************************************************************函数名称：void UART3_SendByte(u8 byte)函数功能：串口发送单字节函数入口参数：byte-待发送字节数据返回值： 无说明 ： *******************************************************************/void UART3_SendByte(u8 byte)&#123; UART3-&gt;DR=byte; while (!(UART3-&gt;SR &amp; 0x80));//等待发送完成&#125;/******************************************************************函数名称：void UART3_SendString(u8* str)函数功能：串口发送字符串函数入口参数：str-待发送字符串返回值： 无说明 ： 无 *******************************************************************/void UART3_SendString(u8* str)&#123; while (*str != '\0') &#123; UART3_SendByte(*str); str++; &#125;&#125;void u3_printf(char* fmt,...) &#123; u16 i,j; va_list ap; va_start(ap,fmt); vsprintf((char*)USART3_TX_BUF,fmt,ap); va_end(ap); i=strlen((const char*)USART3_TX_BUF); //此次发送数据的长度 for(j=0;j&lt;i;j++) //循环发送数据 &#123; while(UART3_GetFlagStatus(UART3_FLAG_TC) ==RESET); //循环发送,直到发送完毕 UART3_SendData8(USART3_TX_BUF[j]); &#125; &#125;到了这一步,串口就基本OK了,但是我们还需要接受,这里就需要中断函数了123456789101112131415161718192021222324252627282930313233343536373839404142INTERRUPT_HANDLER(UART3_RX_IRQHandler, 21)&#123; u8 res; if (UART3-&gt;SR &amp; UART3_FLAG_RXNE)//接收中断(接收到的数据必须是0x0d 0x0a结尾) &#123; res = (u8)UART3-&gt;DR;//读取接收到的数据 if ((USART3_RX_STA &amp; 0x80) == 0)//接收未完成 &#123; if (USART3_RX_STA &amp; 0x40)//接收到了0x0d &#123; if (res != 0x0A)//接收错误,重新开始 &#123; USART3_RX_STA = 0; &#125; else//接收完成 &#123; USART3_RX_STA|= 0x80; &#125; &#125; else//还没收到0X0D &#123; if (res == 0x0D) &#123; USART3_RX_STA|= 0x40; &#125; else &#123; USART3_RX_BUF[USART3_RX_STA&amp;0x3F] = res; USART3_RX_STA++; if (USART3_RX_STA &gt; U3RxBufferSize-1)//接收数据错误,重新开始接收 &#123; USART3_RX_STA = 0; &#125; &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>stm8</category>
      </categories>
      <tags>
        <tag>stm8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[stm8学习笔记-定时器]]></title>
    <url>%2F2018%2F04%2F15%2Fstm8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%AE%9A%E6%97%B6%E5%99%A8%2F</url>
    <content type="text"><![CDATA[前言这一篇,大概说一下定时器的配置,定时器在我们实际运用中,非常重要,一个定时器可以做很多的工作,所以,这一篇就讲一下如何配置。定时器配置定时器配置很简单，首先我们需要添加库函数，这里我配置的是定时器1，所以添加stm8s_tim1.c与.h文件,然后我们要配置TIM1_TimeBaseInit这个函数.这个函数有4个入口参数,TIM1_Prescaler是设置定时器的预分频值, TIM1_CounterMode是设置定时器的计数模式， TIM1_Period是设置定时器的自动重装载值， TIM1_RepetitionCounter是定时器的重复计数值;定时的时长取决于：设置的时钟频率÷预分频值÷自动重装载值；这里我设置的时钟频率是16M高速时钟，16分频，1000的自动重装载值，所以16M/16/1000 = 1KHz = 1ms;然后我们需要使能自动预装载与中断，它们分别是：最后我们使能定时器就可以了:具体怎样配置定时器就说到这里，接下来看程序.程序1234567891011121314151617181920timer.c/** ****************************************************************************** * @文件名 timer.c * @作者 ycx * @版本号 V1.0.0 * @日期 09/01/2018 * @功能 ********************************************************************************//* includes ------------------------------------------------------------------*/#include "timer.h"/* function ------------------------------------------------------------------*/void TIMER1_Init(u16 psc, u16 arr, u8 count)&#123; TIM1_TimeBaseInit(psc, TIM1_COUNTERMODE_UP, arr, count); TIM1_ARRPreloadConfig(ENABLE);//使能自动重装 TIM1_ITConfig(TIM1_IT_UPDATE , ENABLE);//数据更新中断 TIM1_Cmd(ENABLE);//开定时器&#125;123456789101112131415161718timer.h/** ****************************************************************************** * @文件名 timer.h * @作者 ycx * @版本号 V1.0.0 * @日期 09/01/2018 * @功能 ********************************************************************************//* includes ------------------------------------------------------------------*/#ifndef __TIMER_H#define __TIMER_H#include "stm8s.h"/* function ------------------------------------------------------------------*/void TIMER1_Init(u16 psc, u16 arr, u8 count);#endif123456789101112131415161718192021222324252627282930313233343536373839main.c/** ****************************************************************************** * @文件名 main.c * @作者 ycx * @版本号 V1.0.0 * @日期 05/01/2018 * @功能 定时器1 ********************************************************************************//* includes ------------------------------------------------------------------*/#include "stm8s.h"#include "led.h"#include "delay.h"#include "clk.h"#include "key.h"#include "timer.h"/* typedef ------------------------------------------------------------------*//* define ------------------------------------------------------------------*//* variables ------------------------------------------------------------------*//* constants ------------------------------------------------------------------*//* function ------------------------------------------------------------------*/int main(void)&#123; /*设置内部高速时钟16M为主时钟*/ CLK_Config(CLK_PRESCALER_HSIDIV1); TIMER1_Init(16, 1000, 0);//(16M/16)/1000 = 1kHz = 1ms LED_Init(); Key_Init(); delay_init(16); __enable_interrupt(); while (1) &#123; &#125;&#125;主函数什么都没有放，是因为我把需要实现的功能放在了定时器的中断里12345678910111213141516171819202122232425#include "stm8s_it.h"#include "timer.h"#include "led.h"#include "key.h"volatile u16 tim_count = 0;INTERRUPT_HANDLER(TIM1_UPD_OVF_TRG_BRK_IRQHandler, 11)&#123; /* In order to detect unexpected events during development, it is recommended to set a breakpoint on the following instruction. */ u8 key; tim_count++; if (tim_count == 1000) //每1S灯的状态翻转一次 &#123; LED1 = ~LED1; LED2 = ~LED2; LED3 = ~LED3; tim_count = 0; &#125; TIM1-&gt;SR1 &amp;= 0&lt;&lt;0; //清除中断标志 &#125;结语stm8定时器相对于stm32来说配置起来简单了许多,所以应该不会特别难理解,多用就会了.]]></content>
      <categories>
        <category>stm8</category>
      </categories>
      <tags>
        <tag>stm8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[stm8学习笔记-LED]]></title>
    <url>%2F2018%2F04%2F14%2Fstm8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-LED%2F</url>
    <content type="text"><![CDATA[前言这是之前博客发过的东西了,现在重新上传上来而已.LED配置这是我买的stm8s103F3的最小系统板灯上的原理图，从原理图可以看到，当拉高PB5时，LED灭，拉低PB5时，LED亮，所以我们需要配置PB5端口为输出，通过控制端口输出电平来控制灯的亮灭接下来我们讲一下如何配置：因为我最小系统板上的LED灯是在PB5 所以我们配置PB5为推挽输出,10MHz配置完后，我们拉高或拉低需要借助输出寄存器ODR通过对位5写1或者写0来拉高拉低,基本配置就这些，接下来看程序程序1234567891011121314151617181920212223242526led.c/** ****************************************************************************** * @文件名 led.c * @作者 ycx * @版本号 V1.0.0 * @日期 06/01/2018 * @功能 ********************************************************************************//* includes ------------------------------------------------------------------*/#include "led.h"/* function ------------------------------------------------------------------*//******************************************************************函数名称：void LED_Init(void)函数功能：LED初始化入口参数：无返回值： 无说明 ： *******************************************************************/void LED_Init(void)&#123; PB_DDR |= 1&lt;&lt;5;//设置为输出 PB_CR1 |= 1&lt;&lt;5;//推挽输出 PB_CR2 |= 1&lt;&lt;5;//10Mhz&#125;1234567891011121314151617181920led.h/** ****************************************************************************** * @文件名 led.h * @作者 ycx * @版本号 V1.0.0 * @日期 06/01/2018 * @功能 ********************************************************************************//* includes ------------------------------------------------------------------*/#ifndef __LED_H#define __LED_H#include "stm8.h"/* define ------------------------------------------------------------------*/#define LED_ON PB_ODR&amp;=0&lt;&lt;5 //这里用宏定义的方式来拉高拉低LED#define LEDOFF PB_ODR|=1&lt;&lt;5/* function ------------------------------------------------------------------*/void LED_Init(void);#endif1234567891011121314151617181920212223242526272829303132333435main.c/** ****************************************************************************** * @文件名 main.c * @作者 ycx * @版本号 V1.0.0 * @日期 06/01/2018 * @功能 LED ********************************************************************************//* includes ------------------------------------------------------------------*/#include "stm8.h"#include "led.h"#include "clk.h"#include "delay.h"/* typedef ------------------------------------------------------------------*//* define ------------------------------------------------------------------*//* variables ------------------------------------------------------------------*//* function ------------------------------------------------------------------*//* constants ------------------------------------------------------------------*/int main(void)&#123; CLK_Init(); LED_Init(); delay_init(16);//延时由于刚接触stm8所以用的死等的方式 while (1) &#123; LED_ON; delay_ms(200); LEDOFF; delay_ms(200); &#125;&#125;这样一个LED灯就亮起来了]]></content>
      <categories>
        <category>stm8</category>
      </categories>
      <tags>
        <tag>stm8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java开发环境安装及环境变量配置]]></title>
    <url>%2F2018%2F04%2F13%2FJava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E5%8F%8A%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[#前言最近,开始教Java,发现很多人安装了Java后出现了各种问题,这里就对Java安装步骤及环境变量配置作详细的介绍.安装Java开发环境JDK下载首先,打开下载网站：www.oracle.com,根据箭头方向找到Java SE,进入页面后,在下方找到Download Java SE for Developers,并打开它打开后页面是这样的:这里要提醒一下,最好不要装Java最新的版本,因为新版本中环境变量和旧的不同,而且新版本配置后部分人反映配置后不能使用.所以这里我们向下找到Java SE 8u161/ 8u162,并点击JDK下面的DOWNLOAD,这里我选择的是Java SE Development Kit 8u162,选择适合你电脑的位,这里我的是64位,所以下载了64位的安装包.JDK安装根据上面的步骤,我们下载好了JDK的安装包后,我们打开安装包,后点击下一步进行安装,这里要注意的是：最好不要更改安装目录,因为部分安装到别的目录不会配置环境变量,所以为了不必要的麻烦,尽量不要更改安装目录.点击”下一步”后,程序就开始安装了,JDK安装完成后,会提示你是否安装JRE,同样的,我们不修改安装目录,直接下一步开始安装就行了安装完成后,我们点击关闭就可以了.到这里,你的Java开发环境算是安装成功了.接下来我们说一下如何配置JDK环境变量.JDK环境变量配置在资源管理器中,右击我的电脑,选择属性,在弹出来的系统面板中选择高级系统属性,在弹出来的系统属性中,我们打开环境变量.这里我们在系统变量中添加变量名: JAVA_HOME变量值: C:\Program Files\Java\jdk1.8.0_162接下来,在系统变量中寻找”Path”变量,如果不存在,则新建变量”Path”,如果存在,则选中编辑它.在变量值最前面,添加:%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;添加完后,确认,在系统变量中寻找”CLASSPATH”,和上面一样,如果存在则编辑,不存在则新建,变量名: CLASSPATH变量值: %JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;全部添加好后,我们点击确定,回到桌面,win+R输入cmd,打开cmd命令窗口,输入以下命令:`java -versionjavac -versionset JAVA_HOME`输出窗口如下信息,即为配置成功:结语配置环境变量最重要的是细心,如果少一个标点符号都有可能导致后面验证窗口信息失败,所以请准确的安装步骤来配置.]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[stm32AD采样滤波之中位值平均滤波]]></title>
    <url>%2F2018%2F04%2F13%2Fstm32AD%E9%87%87%E6%A0%B7%E6%BB%A4%E6%B3%A2%E4%B9%8B%E4%B8%AD%E4%BD%8D%E5%80%BC%E5%B9%B3%E5%9D%87%E6%BB%A4%E6%B3%A2%2F</url>
    <content type="text"><![CDATA[前言水温中,我们说到了为了防止AD波动使得送入表中查到的温度上下跳动,那么怎么坐到防止AD波动大呢,这就需要我们的滤波算法了.相信很多初学者,一开始学习ADC时,都是用的均值滤波，取十次值求平均,这种滤波方式如果AD跳动略快就会不精准,所以这里我提供了另一种滤波的方式.滤波算法滤波讲解先对AD取N次值(N为奇数),对AD采样值进行排序,然后去掉一个最大与一个最小，计算N-2个数据的算术平均值，这个值作为本次AD的实际采样值这个方法结合了普通均值滤波的优点,又在它的基础上提高了精度，通过排序去掉了最小与最大,但是在提高的精度的前提,是十分浪费CPU的.不过这对于stm32资源丰富的芯片来说,这个滤波方法不失为一个提升AD精度的方式.滤波算法12345678910111213141516171819202122232425262728293031#define N 13u16 Get_Adc_Average(u8 ch)&#123; u16 value_buf[N]; u16 temp; u8 count, i, j; for (count=0; count&lt;N; count++) &#123; value_buf[count] = Get_Adc(ch); delay_ms(5); &#125; for (j=0; j&lt;N-1; j++) //冒泡排序 &#123; for (i=0; i&lt;N-j-1; i++) &#123; if (value_buf[i] &gt; value_buf[i+1]) &#123; temp = value_buf[i]; value_buf[i] = value_buf[i+1]; value_buf[i+1] = temp; &#125; &#125; &#125; temp = 0; for (count=1; count&lt;N-1; count++) &#123; temp += value_buf[count]; &#125; return temp/(N-2);//把N次采样值按大小排列 ，取中间值为本次有效值&#125;结语滤波算法有很多种,这只是其中的一种,不同的滤波方式适用与不同的环境,所以怎么选择一个滤波方式,还是要根据使用的实际情况.]]></content>
      <categories>
        <category>stm32</category>
      </categories>
      <tags>
        <tag>stm32</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[stm32f030水温控制(完)]]></title>
    <url>%2F2018%2F04%2F13%2Fstm32f030%E6%B0%B4%E6%B8%A9%E6%8E%A7%E5%88%B6-%E5%AE%8C%2F</url>
    <content type="text"><![CDATA[前言前面的子模块的基本配置已经讲过了,这一篇算是完结篇了,本篇只讲大致如何实现各模块组合实现水温控制,程序子模块都已经有了,剩下的只是把子模块整合在一起,实现一个具体的功能.程序程序框架首先你得确保你的子模块单独运行时没有错误,可以实现单独的功能,如果连基本的独立工作的功能都无法实现,整合就谈不上了.框架讲解 再次提醒一下,一定要确保你每个子模块都能独立运行确保你的系统能有一个1s翻转1次的LED指示灯(确保程序在运行)通过定义变量获取AD值,输入滤波算法得到滤波后的AD值(确保精准)滤波后的AD最好尽量精准平稳,因为可以确保查表后温度跳动不会特别明显.EC11确认能通过左旋右旋控制设定的温度值,并且要保证EC11按键精准可控,并且将设定的温度与实际温度分别显示在数码管中.将获取的实际温度与设定温度传入pid算法,并且通过pid参数整定不断调整到系统最佳.将Pid的输出通过改变PWM实现控温效果.时间要求1.LED – 1S翻转(有两个指示灯,建议一个用来做系统运行指示灯,另一个调试用)2.AD采集 – 10ms-50ms采集一次.查表获取温度 – 30-60ms查一次表(使得数码管显示的实际温度不会跳变太快)对实际温度与设定温度进行运算送入数码管 – 300ms(同上,使得数码管跳变不会太快)数码管动态扫描 – 0.01ms扫描一次(确保数码管不会亮度太暗,或者人眼可以看见跳动)pid运算 – 建议直接放在while(反馈系统一直在线)模块整合建议通过上述框架一点点加入子模块,确保每次加入子模块后程序还能继续运行.通过程序框图,与每个模块执行认为的时间,基本可以实现控温,这里需要提醒的是,最好不要阻塞程序运行,否则效率会低.模块整合这边不会贴出代码,只给出了思路,至于怎么整合,只要稍微有C语言的基础,都能对程序逻辑做出很好的实现,程序子模块都确保可以运行,剩下的基本就是逻辑方面上的问题了.视频实际效果可参考：点击这儿点击这儿这里误差大概 -1 到 +1度之间.补充上面视频里,温度跳动稍微有些快,后来做了修改:1.之前是10ms采集AD,后来修正为500ms采一次AD.2.PID参数微调.比上面效果会更好,但是没法上传.结语看到这里,水温控制已经完结了,如果你有什么疑问可以评论问我,我看到会尽量回复的.]]></content>
      <categories>
        <category>stm32</category>
      </categories>
      <tags>
        <tag>stm32</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于stm32f030水温控制5]]></title>
    <url>%2F2018%2F04%2F13%2F%E5%9F%BA%E4%BA%8Estm32f030%E6%B0%B4%E6%B8%A9%E6%8E%A7%E5%88%B65%2F</url>
    <content type="text"><![CDATA[前言到这里,子模块已经写了4篇了,这一篇就对最为核心的pid做完介绍就开始简单讲模块整合了.pid分许多种,位置式pid、增量式pid、积分分离pid、抗积分饱和性pid、梯形积分pid、模糊Pid等等.P是比例,I是积分,D是微分.就我的理解,它是一个自动控制系统,我们核心的就是pid参数的整定,至于pid究竟是个什么东西.网上有一大把讲的比我透彻的资料,这里我就不献丑了.PIDpid算法的选择我大概用了C语音打印出来的表,从图里看位置型,上升的斜率比较平缓,适合水温上升的幅度,增量式的和位置式的接近,这里我没贴出图,所以我用的是位置式pid至于位置式和增量式如何选择,我是不知道从哪里看到的资料,说位置式适用于没有记忆性器件的环境,而增量式相反,而水温加热这边我只是控制固态继电器开关,没有记忆性的环境,所以我选择的是位置式Pid,并不是说只有位置式可以达到要求,增量式其实也是可以的至于如何选择,还需根据自己的实际情况来决定.pid实现首先,我们定义一个pid的结构体,并声明它.接下来,我们设置个函数初始化这些参数,初始化好了后,就是我们的核心算法了,pid参数整定老实说我也不太会,调整参数这边,我的建议是先不加入积分与微分,仅加入比例控制,直到系统可以到达你所设置温度,接下来过冲,振荡建议用串口打印后生成表格来调整积分与比例.参数整定这边,我能给出的建议就这些,毕竟我也是初学Pid.这里给出常用的口诀:参数整定找最佳，从小到大顺序查 先是比例后积分，最后再把微分加 曲线振荡很频繁，比例度盘要放大 曲线漂浮绕大湾，比例度盘往小扳 曲线偏离回复慢，积分时间往下降 曲线波动周期长，积分时间再加长 曲线振荡频率快，先把微分降下来 动差大来波动慢。微分时间应加长 理想曲线两个波，前高后低四比一 一看二调多分析，调节质量不会低补充忘了说了,我的是NTC采集的温度,所以需要配置AD采集与对NTC温度表对应.这里给出ADC配置NTC对应的温度表这里就不发了,根据自己实际的电压才能使得AD对应的温度更精准]]></content>
      <categories>
        <category>stm32</category>
      </categories>
      <tags>
        <tag>stm32</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于stm32f030水温控制4]]></title>
    <url>%2F2018%2F04%2F13%2F%E5%9F%BA%E4%BA%8Estm32f030%E6%B0%B4%E6%B8%A9%E6%8E%A7%E5%88%B64%2F</url>
    <content type="text"><![CDATA[前言这一篇,说一下水温加热方面,这里水温加热这边,我们用的是固态继电器,一端连接加热棒,一端连接单片机驱动MOS电路.从原理图可以看出,我们只要输出高低电平就可以实现水温加热,通过LED指示灯观察是否加热.既然用到了拉高拉低,既可以用周期性拉高拉低实现PWM,也可以使用定时器输出PWM,这里资源充足,所以用的是定时器配置PWM定时器PWM配置配置这边,在图片里,也给了相应注释配置方面可以根据自己实际需要去修改分频值与重装载值.补充配置好定时器后,我们如何通过实际来修改占空比，难道每次修改都要重新初始化一次吗?答案是不用的,stm32f0中库给出了修改占空比的函数,TIM_SetCompare4(TIMx, duty);TIM_SetCompare4 后面的4标示了通道,TIMx通过更改x可以选择TIM1,TIM2等定时器, duty则是你要传入的占空比,这与你的重装值有关这里还需强调,我用的是stm32f030K6,系统时钟为48M.PWM频率是由系统时钟除于你的分频值得到的,例如我设置分频值为2400则频率f = 48M / 2400 = 20000Hz = 20KHz,可以推算出计算周期为 = 1/20KHz = 0.00005s = 50us结语这一章配置定时器,十分简单的达到了加热的效果,如何达到水温控制,则要用到PID算法,这个后面再说.]]></content>
      <categories>
        <category>stm32</category>
      </categories>
      <tags>
        <tag>stm32</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于stm32f030水温控制3]]></title>
    <url>%2F2018%2F04%2F13%2F%E5%9F%BA%E4%BA%8Estm32f030%E6%B0%B4%E6%B8%A9%E6%8E%A7%E5%88%B63%2F</url>
    <content type="text"><![CDATA[前言上一篇,我们说到了旋转编码器EC11的实现,这篇我们讲一下数码管.首先,我的板上用到的数码管有两片,一片4位,分别用两个595驱动,节省IO口. 数码管用的是3461BS,共阳极的数码管,驱动数码管,只需把我们的段码与位通过595发送到数码管的管脚,原理简单,这里就不多说了. 数码管配置595连接芯片的IO分别是DIO-PB5 RCLK-PA15 SCLK-PB3,这里只要配置为推挽输出就可以了.数码管显示配置先看显示这边,传入参数L1,L2,L3,L4分别对应数码管4个位所要显示的段码,H代表选择显示的是第一块数码管还是第二块 0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80分别是位码最后把要显示的段码,通过函数传入. 把要写入数码管的数据,写入函数 _3461BS_Date(u8 date),送入数码管. 结语通过调用函数,我们可以实现静态显示,至于如何动态显示,我们后面再说. 最后贴上实物图:]]></content>
      <categories>
        <category>stm32</category>
      </categories>
      <tags>
        <tag>stm32</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于stm32f030水温控制2]]></title>
    <url>%2F2018%2F04%2F12%2F%E5%9F%BA%E4%BA%8Estm32f030%E6%B0%B4%E6%B8%A9%E6%8E%A7%E5%88%B62%2F</url>
    <content type="text"><![CDATA[前言承接上一篇的水温控制,这一篇我们把控制设定温度的旋转编码器EC11讲一下.EC11预备知识EC11旋转编码器是一种小型高精度旋转式编码器,在结构上,由编码器部分和按键部分组合而成,这里我用到了EC11A相和B相与一个按键.我们需要编写的就是如何判断旋转的方向与按键的检测.从图中我们可以看出,假设检测A相上升沿,我们只需判断B相的高低电平就可以知道旋转的是正向或是逆向,知道了如何检测,配置就方便多了,接下来我们讲一下如何配置.EC11配置时钟配置这边由于我的A相B相和按键所在IO都在PA上,所以我打开了GPIOA的时钟,由于需要映射中断管脚,所以开启了SYSCFG时钟.管脚配置这边,直接配置IO为上拉输入,这里有别与F1系列的我上一篇已经讲过了.这里就不多说了中断,要映射管脚,这里我用的是PA10,所以映射了中断线10,配置好中断,我们就只需要在中断函数里检测另一相的电平就可以了,这里我就不在多说了.最后设置一下中断优先级就可以了.按键配置按键的配置其实上面已经有了,这里我们讲一下如何检测按键,通常扫按键的方法都是延时10ms,但是这种方式延时,不一定能达到我们要的效果.所以这里我介绍一下状态机按键消抖的方式.通过上面的状态跳转,实现判断按键抬起、长按、连按,相比延时扫描按键的方法,好了很多.结语这里简单的讲了EC11AB相的检测以及按键的扫描方法,如果文中有哪些错误,希望你能给我发邮件告知,感激不尽.]]></content>
      <categories>
        <category>stm32</category>
      </categories>
      <tags>
        <tag>stm32</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于stm32f030水温控制1]]></title>
    <url>%2F2018%2F04%2F12%2F%E5%9F%BA%E4%BA%8Estm32f030%E6%B0%B4%E6%B8%A9%E6%8E%A7%E5%88%B61%2F</url>
    <content type="text"><![CDATA[前言这篇博客是基于我老师布置的项目”stm32f030水温控制”所写的,我会把每个模块的基本配置为大家进行讲解.好啦闲话不多说,进入我们的正题.LED和蜂鸣器的配置LED或者是蜂鸣器(BEEP)基本上是我们学习32的基础,配置这方面十分简单,所以我会简单的略过一些配置.我的板上LED和蜂鸣器与单片机相连的IO口有三个,分别是LED1-PA11 LED2-PA12 BEEP-PA0,接下来我们就说一下如何配置.首先,我们需要定义GPIO结构体与PA口的时钟,这里有别与F1系列的配置,F0PA口上的时钟是在AHB总线上,而F1PA口上的时钟是APB2,所以这里我们要区分一下,否则会报错.配置完时钟,我们就可以对IO口进行配置了,这里我设置了IO口为推挽输出,速度为50MHz,这里要强调的是,F0区别与F1的是,IO口配置这边,不能直接像F1一样推挽和输出是同时配置的,F0是分别配置的,还有就是右击IO口速度那里,我们可以看到:可以看出,如果我们使用GPIO_Speed_Level_3也可以代替GPIO_Speed_50MHz,可以更直观的看出IO口速度,具体怎样选择,还是得看个人选择.最后,在配置一下GPIO_Init函数就基本配置完成.那么,我们如何使得LED翻转呢,这里就可以用到GPIO_SetBits和GPIO_ResetBits两个函数,不过我还是喜欢用F1的位带操作.所以等一下,我们讲一下如何配置F0来实现位带操作.位带操作的配置位带操作,可以使我们输出高低电平时给1 or 0来实现,这样可以方便我们操控IO口,而且方便快捷,如果用操作函数的方式,翻转IO口就有点麻烦,所以这里我们设置下位带操作.我们可以在所在的工程中添加stm32f0xx_sys.h的头文件来存放,当我们需要使用位带操作时,直接调用就可以了.1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#ifndef __STM32F0xx_SYS_H#define __STM32F0xx_SYS_Htypedef struct&#123; unsigned short int b0 : 1; unsigned short int b1 : 1; unsigned short int b2 : 1; unsigned short int b3 : 1; unsigned short int b4 : 1; unsigned short int b5 : 1; unsigned short int b6 : 1; unsigned short int b7 : 1; unsigned short int b8 : 1; unsigned short int b9 : 1; unsigned short int b10 : 1; unsigned short int b11 : 1; unsigned short int b12 : 1; unsigned short int b13 : 1; unsigned short int b14 : 1; unsigned short int b15 : 1;&#125;REG16_TypeDef;//IO口地址映射#define GPIOA_ODR_Addr (GPIOA_BASE+0x14) //0x48000014#define GPIOB_ODR_Addr (GPIOB_BASE+0x14) //0x48000414#define GPIOC_ODR_Addr (GPIOC_BASE+0x14) //0x48000814#define GPIOD_ODR_Addr (GPIOD_BASE+0x14) //0x48000C14#define GPIOE_ODR_Addr (GPIOE_BASE+0x14) //0x48001014#define GPIOF_ODR_Addr (GPIOF_BASE+0x14) //0x48001414#define GPIOA_IDR_Addr (GPIOA_BASE+0x10) //0x48000010#define GPIOB_IDR_Addr (GPIOB_BASE+0x10) //0x48000410#define GPIOC_IDR_Addr (GPIOC_BASE+0x10) //0x48000810#define GPIOD_IDR_Addr (GPIOD_BASE+0x10) //0x48000C10#define GPIOE_IDR_Addr (GPIOE_BASE+0x10) //0x48001010#define GPIOF_IDR_Addr (GPIOF_BASE+0x10) //0x48001410 //IO口操作,只对单一的IO口!//确保n的值小于16!#define PAout ((volatile REG16_TypeDef *)GPIOA_ODR_Addr) //输出 #define PAin ((volatile REG16_TypeDef *)GPIOA_IDR_Addr) //输入 #define PBout ((volatile REG16_TypeDef *)GPIOB_ODR_Addr) //输出 #define PBin ((volatile REG16_TypeDef *)GPIOB_IDR_Addr) //输入 #define PCout ((volatile REG16_TypeDef *)GPIOC_ODR_Addr) //输出 #define PCin ((volatile REG16_TypeDef *)GPIOC_IDR_Addr) //输入 #define PDout ((volatile REG16_TypeDef *)GPIOD_ODR_Addr) //输出 #define PDin ((volatile REG16_TypeDef *)GPIOD_IDR_Addr) //输入 #define PEout ((volatile REG16_TypeDef *)GPIOE_ODR_Addr) //输出 #define PEin ((volatile REG16_TypeDef *)GPIOE_IDR_Addr) //输入#define PFout ((volatile REG16_TypeDef *)GPIOF_ODR_Addr) //输出 #define PFin ((volatile REG16_TypeDef *)GPIOF_IDR_Addr) //输入typedef unsigned char u8;typedef unsigned short int u16;typedef unsigned int u32; #endif这样位带操作就已经配置好了.结语因为时间的问题,我没有办法把整个工程一次性讲完,所以我会分篇讲解,今天就先说的这里,我只是个学生,如果在文章中有什么错误的地方,请不吝指教,谢谢！]]></content>
      <categories>
        <category>stm32</category>
      </categories>
      <tags>
        <tag>stm32</tag>
      </tags>
  </entry>
</search>
